THREE.OutlinePass=function(a,d,c,b){this.renderScene=d;this.renderCamera=c;this.selectedObjects=void 0!==b?b:[];this.visibleEdgeColor=new THREE.Color(1,1,1);this.hiddenEdgeColor=new THREE.Color(.1,.04,.02);this.edgeGlow=0;this.usePatternTexture=!1;this.edgeThickness=1;this.edgeStrength=3;this.downSampleRatio=2;this.pulsePeriod=0;THREE.Pass.call(this);this.resolution=void 0!==a?new THREE.Vector2(a.x,a.y):new THREE.Vector2(256,256);a={minFilter:THREE.LinearFilter,magFilter:THREE.LinearFilter,format:THREE.RGBAFormat};
d=Math.round(this.resolution.x/this.downSampleRatio);c=Math.round(this.resolution.y/this.downSampleRatio);this.maskBufferMaterial=new THREE.MeshBasicMaterial({color:16777215});this.maskBufferMaterial.side=THREE.DoubleSide;this.renderTargetMaskBuffer=new THREE.WebGLRenderTarget(this.resolution.x,this.resolution.y,a);this.renderTargetMaskBuffer.texture.name="OutlinePass.mask";this.renderTargetMaskBuffer.texture.generateMipmaps=!1;this.depthMaterial=new THREE.MeshDepthMaterial;this.depthMaterial.side=
THREE.DoubleSide;this.depthMaterial.depthPacking=THREE.RGBADepthPacking;this.depthMaterial.blending=THREE.NoBlending;this.prepareMaskMaterial=this.getPrepareMaskMaterial();this.prepareMaskMaterial.side=THREE.DoubleSide;b=this.prepareMaskMaterial;var e;e=this.prepareMaskMaterial.fragmentShader.replace(/DEPTH_TO_VIEW_Z/g,(this.renderCamera.isPerspectiveCamera?"perspective":"orthographic")+"DepthToViewZ");b.fragmentShader=e;this.renderTargetDepthBuffer=new THREE.WebGLRenderTarget(this.resolution.x,this.resolution.y,
a);this.renderTargetDepthBuffer.texture.name="OutlinePass.depth";this.renderTargetDepthBuffer.texture.generateMipmaps=!1;this.renderTargetMaskDownSampleBuffer=new THREE.WebGLRenderTarget(d,c,a);this.renderTargetMaskDownSampleBuffer.texture.name="OutlinePass.depthDownSample";this.renderTargetMaskDownSampleBuffer.texture.generateMipmaps=!1;this.renderTargetBlurBuffer1=new THREE.WebGLRenderTarget(d,c,a);this.renderTargetBlurBuffer1.texture.name="OutlinePass.blur1";this.renderTargetBlurBuffer1.texture.generateMipmaps=
!1;this.renderTargetBlurBuffer2=new THREE.WebGLRenderTarget(Math.round(d/2),Math.round(c/2),a);this.renderTargetBlurBuffer2.texture.name="OutlinePass.blur2";this.renderTargetBlurBuffer2.texture.generateMipmaps=!1;this.edgeDetectionMaterial=this.getEdgeDetectionMaterial();this.renderTargetEdgeBuffer1=new THREE.WebGLRenderTarget(d,c,a);this.renderTargetEdgeBuffer1.texture.name="OutlinePass.edge1";this.renderTargetEdgeBuffer1.texture.generateMipmaps=!1;this.renderTargetEdgeBuffer2=new THREE.WebGLRenderTarget(Math.round(d/
2),Math.round(c/2),a);this.renderTargetEdgeBuffer2.texture.name="OutlinePass.edge2";this.renderTargetEdgeBuffer2.texture.generateMipmaps=!1;this.separableBlurMaterial1=this.getSeperableBlurMaterial(4);this.separableBlurMaterial1.uniforms.texSize.value=new THREE.Vector2(d,c);this.separableBlurMaterial1.uniforms.kernelRadius.value=1;this.separableBlurMaterial2=this.getSeperableBlurMaterial(4);this.separableBlurMaterial2.uniforms.texSize.value=new THREE.Vector2(Math.round(d/2),Math.round(c/2));this.separableBlurMaterial2.uniforms.kernelRadius.value=
4;this.overlayMaterial=this.getOverlayMaterial();void 0===THREE.CopyShader&&console.error("THREE.OutlinePass relies on THREE.CopyShader");a=THREE.CopyShader;this.copyUniforms=THREE.UniformsUtils.clone(a.uniforms);this.copyUniforms.opacity.value=1;this.materialCopy=new THREE.ShaderMaterial({uniforms:this.copyUniforms,vertexShader:a.vertexShader,fragmentShader:a.fragmentShader,blending:THREE.NoBlending,depthTest:!1,depthWrite:!1,transparent:!0});this.enabled=!0;this.needsSwap=!1;this.oldClearColor=
new THREE.Color;this.oldClearAlpha=1;this.camera=new THREE.OrthographicCamera(-1,1,1,-1,0,1);this.scene=new THREE.Scene;this.quad=new THREE.Mesh(new THREE.PlaneBufferGeometry(2,2),null);this.quad.frustumCulled=!1;this.scene.add(this.quad);this.tempPulseColor1=new THREE.Color;this.tempPulseColor2=new THREE.Color;this.textureMatrix=new THREE.Matrix4};
THREE.OutlinePass.prototype=Object.assign(Object.create(THREE.Pass.prototype),{constructor:THREE.OutlinePass,dispose:function(){this.renderTargetMaskBuffer.dispose();this.renderTargetDepthBuffer.dispose();this.renderTargetMaskDownSampleBuffer.dispose();this.renderTargetBlurBuffer1.dispose();this.renderTargetBlurBuffer2.dispose();this.renderTargetEdgeBuffer1.dispose();this.renderTargetEdgeBuffer2.dispose()},setSize:function(a,d){this.renderTargetMaskBuffer.setSize(a,d);var c=Math.round(a/this.downSampleRatio),
b=Math.round(d/this.downSampleRatio);this.renderTargetMaskDownSampleBuffer.setSize(c,b);this.renderTargetBlurBuffer1.setSize(c,b);this.renderTargetEdgeBuffer1.setSize(c,b);this.separableBlurMaterial1.uniforms.texSize.value=new THREE.Vector2(c,b);c=Math.round(c/2);b=Math.round(b/2);this.renderTargetBlurBuffer2.setSize(c,b);this.renderTargetEdgeBuffer2.setSize(c,b);this.separableBlurMaterial2.uniforms.texSize.value=new THREE.Vector2(c,b)},changeVisibilityOfSelectedObjects:function(a){function d(c){c instanceof
THREE.Mesh&&(c.visible=a)}for(var c=0;c<this.selectedObjects.length;c++)this.selectedObjects[c].traverse(d)},changeVisibilityOfNonSelectedObjects:function(a){function d(a){a instanceof THREE.Mesh&&c.push(a)}for(var c=[],b=0;b<this.selectedObjects.length;b++)this.selectedObjects[b].traverse(d);this.renderScene.traverse(function(b){if(b instanceof THREE.Mesh||b instanceof THREE.Line||b instanceof THREE.Sprite){for(var d=!1,f=0;f<c.length;f++)if(c[f].id===b.id){d=!0;break}if(!d){d=b.visible;if(!a||b.bVisible)b.visible=
a;b.bVisible=d}}})},updateTextureMatrix:function(){this.textureMatrix.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1);this.textureMatrix.multiply(this.renderCamera.projectionMatrix);this.textureMatrix.multiply(this.renderCamera.matrixWorldInverse)},render:function(a,d,c,b,e){0!==this.selectedObjects.length&&(this.oldClearColor.copy(a.getClearColor()),this.oldClearAlpha=a.getClearAlpha(),d=a.autoClear,a.autoClear=!1,e&&a.context.disable(a.context.STENCIL_TEST),a.setClearColor(16777215,1),this.changeVisibilityOfSelectedObjects(!1),
b=this.renderScene.background,this.renderScene.background=null,this.renderScene.overrideMaterial=this.depthMaterial,a.render(this.renderScene,this.renderCamera,this.renderTargetDepthBuffer,!0),this.changeVisibilityOfSelectedObjects(!0),this.updateTextureMatrix(),this.changeVisibilityOfNonSelectedObjects(!1),this.renderScene.overrideMaterial=this.prepareMaskMaterial,this.prepareMaskMaterial.uniforms.cameraNearFar.value=new THREE.Vector2(this.renderCamera.near,this.renderCamera.far),this.prepareMaskMaterial.uniforms.depthTexture.value=
this.renderTargetDepthBuffer.texture,this.prepareMaskMaterial.uniforms.textureMatrix.value=this.textureMatrix,a.render(this.renderScene,this.renderCamera,this.renderTargetMaskBuffer,!0),this.renderScene.overrideMaterial=null,this.changeVisibilityOfNonSelectedObjects(!0),this.renderScene.background=b,this.quad.material=this.materialCopy,this.copyUniforms.tDiffuse.value=this.renderTargetMaskBuffer.texture,a.render(this.scene,this.camera,this.renderTargetMaskDownSampleBuffer,!0),this.tempPulseColor1.copy(this.visibleEdgeColor),
this.tempPulseColor2.copy(this.hiddenEdgeColor),0<this.pulsePeriod&&(b=.625+.75*Math.cos(.01*performance.now()/this.pulsePeriod)/2,this.tempPulseColor1.multiplyScalar(b),this.tempPulseColor2.multiplyScalar(b)),this.quad.material=this.edgeDetectionMaterial,this.edgeDetectionMaterial.uniforms.maskTexture.value=this.renderTargetMaskDownSampleBuffer.texture,this.edgeDetectionMaterial.uniforms.texSize.value=new THREE.Vector2(this.renderTargetMaskDownSampleBuffer.width,this.renderTargetMaskDownSampleBuffer.height),
this.edgeDetectionMaterial.uniforms.visibleEdgeColor.value=this.tempPulseColor1,this.edgeDetectionMaterial.uniforms.hiddenEdgeColor.value=this.tempPulseColor2,a.render(this.scene,this.camera,this.renderTargetEdgeBuffer1,!0),this.quad.material=this.separableBlurMaterial1,this.separableBlurMaterial1.uniforms.colorTexture.value=this.renderTargetEdgeBuffer1.texture,this.separableBlurMaterial1.uniforms.direction.value=THREE.OutlinePass.BlurDirectionX,this.separableBlurMaterial1.uniforms.kernelRadius.value=
this.edgeThickness,a.render(this.scene,this.camera,this.renderTargetBlurBuffer1,!0),this.separableBlurMaterial1.uniforms.colorTexture.value=this.renderTargetBlurBuffer1.texture,this.separableBlurMaterial1.uniforms.direction.value=THREE.OutlinePass.BlurDirectionY,a.render(this.scene,this.camera,this.renderTargetEdgeBuffer1,!0),this.quad.material=this.separableBlurMaterial2,this.separableBlurMaterial2.uniforms.colorTexture.value=this.renderTargetEdgeBuffer1.texture,this.separableBlurMaterial2.uniforms.direction.value=
THREE.OutlinePass.BlurDirectionX,a.render(this.scene,this.camera,this.renderTargetBlurBuffer2,!0),this.separableBlurMaterial2.uniforms.colorTexture.value=this.renderTargetBlurBuffer2.texture,this.separableBlurMaterial2.uniforms.direction.value=THREE.OutlinePass.BlurDirectionY,a.render(this.scene,this.camera,this.renderTargetEdgeBuffer2,!0),this.quad.material=this.overlayMaterial,this.overlayMaterial.uniforms.maskTexture.value=this.renderTargetMaskBuffer.texture,this.overlayMaterial.uniforms.edgeTexture1.value=
this.renderTargetEdgeBuffer1.texture,this.overlayMaterial.uniforms.edgeTexture2.value=this.renderTargetEdgeBuffer2.texture,this.overlayMaterial.uniforms.patternTexture.value=this.patternTexture,this.overlayMaterial.uniforms.edgeStrength.value=this.edgeStrength,this.overlayMaterial.uniforms.edgeGlow.value=this.edgeGlow,this.overlayMaterial.uniforms.usePatternTexture.value=this.usePatternTexture,e&&a.context.enable(a.context.STENCIL_TEST),a.render(this.scene,this.camera,c,!1),a.setClearColor(this.oldClearColor,
this.oldClearAlpha),a.autoClear=d)},getPrepareMaskMaterial:function(){return new THREE.ShaderMaterial({uniforms:{depthTexture:{value:null},cameraNearFar:{value:new THREE.Vector2(.5,.5)},textureMatrix:{value:new THREE.Matrix4}},vertexShader:"varying vec4 projTexCoord;\nvarying vec4 vPosition;\nuniform mat4 textureMatrix;\nvoid main() {\n\tvPosition \x3d modelViewMatrix * vec4( position, 1.0 );\n\tvec4 worldPosition \x3d modelMatrix * vec4( position, 1.0 );\n\tprojTexCoord \x3d textureMatrix * worldPosition;\n\tgl_Position \x3d projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
fragmentShader:"#include \x3cpacking\x3e\nvarying vec4 vPosition;\nvarying vec4 projTexCoord;\nuniform sampler2D depthTexture;\nuniform vec2 cameraNearFar;\nvoid main() {\n\tfloat depth \x3d unpackRGBAToDepth(texture2DProj( depthTexture, projTexCoord ));\n\tfloat viewZ \x3d - DEPTH_TO_VIEW_Z( depth, cameraNearFar.x, cameraNearFar.y );\n\tfloat depthTest \x3d (-vPosition.z \x3e viewZ) ? 1.0 : 0.0;\n\tgl_FragColor \x3d vec4(0.0, depthTest, 1.0, 1.0);\n}"})},getEdgeDetectionMaterial:function(){return new THREE.ShaderMaterial({uniforms:{maskTexture:{value:null},
texSize:{value:new THREE.Vector2(.5,.5)},visibleEdgeColor:{value:new THREE.Vector3(1,1,1)},hiddenEdgeColor:{value:new THREE.Vector3(1,1,1)}},vertexShader:"varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv \x3d uv;\n\t\t\t\t\tgl_Position \x3d projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}",fragmentShader:"varying vec2 vUv;\t\t\t\tuniform sampler2D maskTexture;\t\t\t\tuniform vec2 texSize;\t\t\t\tuniform vec3 visibleEdgeColor;\t\t\t\tuniform vec3 hiddenEdgeColor;\t\t\t\t\t\t\t\tvoid main() {\n\t\t\t\t\tvec2 invSize \x3d 1.0 / texSize;\t\t\t\t\tvec4 uvOffset \x3d vec4(1.0, 0.0, 0.0, 1.0) * vec4(invSize, invSize);\t\t\t\t\tvec4 c1 \x3d texture2D( maskTexture, vUv + uvOffset.xy);\t\t\t\t\tvec4 c2 \x3d texture2D( maskTexture, vUv - uvOffset.xy);\t\t\t\t\tvec4 c3 \x3d texture2D( maskTexture, vUv + uvOffset.yw);\t\t\t\t\tvec4 c4 \x3d texture2D( maskTexture, vUv - uvOffset.yw);\t\t\t\t\tfloat diff1 \x3d (c1.r - c2.r)*0.5;\t\t\t\t\tfloat diff2 \x3d (c3.r - c4.r)*0.5;\t\t\t\t\tfloat d \x3d length( vec2(diff1, diff2) );\t\t\t\t\tfloat a1 \x3d min(c1.g, c2.g);\t\t\t\t\tfloat a2 \x3d min(c3.g, c4.g);\t\t\t\t\tfloat visibilityFactor \x3d min(a1, a2);\t\t\t\t\tvec3 edgeColor \x3d 1.0 - visibilityFactor \x3e 0.001 ? visibleEdgeColor : hiddenEdgeColor;\t\t\t\t\tgl_FragColor \x3d vec4(edgeColor, 1.0) * vec4(d);\t\t\t\t}"})},
getSeperableBlurMaterial:function(a){return new THREE.ShaderMaterial({defines:{MAX_RADIUS:a},uniforms:{colorTexture:{value:null},texSize:{value:new THREE.Vector2(.5,.5)},direction:{value:new THREE.Vector2(.5,.5)},kernelRadius:{value:1}},vertexShader:"varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv \x3d uv;\n\t\t\t\t\tgl_Position \x3d projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}",fragmentShader:"#include \x3ccommon\x3e\t\t\t\tvarying vec2 vUv;\t\t\t\tuniform sampler2D colorTexture;\t\t\t\tuniform vec2 texSize;\t\t\t\tuniform vec2 direction;\t\t\t\tuniform float kernelRadius;\t\t\t\t\t\t\t\tfloat gaussianPdf(in float x, in float sigma) {\t\t\t\t\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\t\t\t\t}\t\t\t\tvoid main() {\t\t\t\t\tvec2 invSize \x3d 1.0 / texSize;\t\t\t\t\tfloat weightSum \x3d gaussianPdf(0.0, kernelRadius);\t\t\t\t\tvec3 diffuseSum \x3d texture2D( colorTexture, vUv).rgb * weightSum;\t\t\t\t\tvec2 delta \x3d direction * invSize * kernelRadius/float(MAX_RADIUS);\t\t\t\t\tvec2 uvOffset \x3d delta;\t\t\t\t\tfor( int i \x3d 1; i \x3c\x3d MAX_RADIUS; i ++ ) {\t\t\t\t\t\tfloat w \x3d gaussianPdf(uvOffset.x, kernelRadius);\t\t\t\t\t\tvec3 sample1 \x3d texture2D( colorTexture, vUv + uvOffset).rgb;\t\t\t\t\t\tvec3 sample2 \x3d texture2D( colorTexture, vUv - uvOffset).rgb;\t\t\t\t\t\tdiffuseSum +\x3d ((sample1 + sample2) * w);\t\t\t\t\t\tweightSum +\x3d (2.0 * w);\t\t\t\t\t\tuvOffset +\x3d delta;\t\t\t\t\t}\t\t\t\t\tgl_FragColor \x3d vec4(diffuseSum/weightSum, 1.0);\t\t\t\t}"})},
getOverlayMaterial:function(){return new THREE.ShaderMaterial({uniforms:{maskTexture:{value:null},edgeTexture1:{value:null},edgeTexture2:{value:null},patternTexture:{value:null},edgeStrength:{value:1},edgeGlow:{value:1},usePatternTexture:{value:0}},vertexShader:"varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv \x3d uv;\n\t\t\t\t\tgl_Position \x3d projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}",fragmentShader:"varying vec2 vUv;\t\t\t\tuniform sampler2D maskTexture;\t\t\t\tuniform sampler2D edgeTexture1;\t\t\t\tuniform sampler2D edgeTexture2;\t\t\t\tuniform sampler2D patternTexture;\t\t\t\tuniform float edgeStrength;\t\t\t\tuniform float edgeGlow;\t\t\t\tuniform bool usePatternTexture;\t\t\t\t\t\t\t\tvoid main() {\t\t\t\t\tvec4 edgeValue1 \x3d texture2D(edgeTexture1, vUv);\t\t\t\t\tvec4 edgeValue2 \x3d texture2D(edgeTexture2, vUv);\t\t\t\t\tvec4 maskColor \x3d texture2D(maskTexture, vUv);\t\t\t\t\tvec4 patternColor \x3d texture2D(patternTexture, 6.0 * vUv);\t\t\t\t\tfloat visibilityFactor \x3d 1.0 - maskColor.g \x3e 0.0 ? 1.0 : 0.5;\t\t\t\t\tvec4 edgeValue \x3d edgeValue1 + edgeValue2 * edgeGlow;\t\t\t\t\tvec4 finalColor \x3d edgeStrength * maskColor.r * edgeValue;\t\t\t\t\tif(usePatternTexture)\t\t\t\t\t\tfinalColor +\x3d + visibilityFactor * (1.0 - maskColor.r) * (1.0 - patternColor.r);\t\t\t\t\tgl_FragColor \x3d finalColor;\t\t\t\t}",
blending:THREE.AdditiveBlending,depthTest:!1,depthWrite:!1,transparent:!0})}});THREE.OutlinePass.BlurDirectionX=new THREE.Vector2(1,0);THREE.OutlinePass.BlurDirectionY=new THREE.Vector2(0,1);