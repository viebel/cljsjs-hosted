THREE.PMREMCubeUVPacker=function(b,l){this.cubeLods=b;this.numLods=l;var c=4*b[0].width,a=b[0].texture,a={format:a.format,magFilter:a.magFilter,minFilter:a.minFilter,type:a.type,generateMipmaps:a.generateMipmaps,anisotropy:a.anisotropy,encoding:a.encoding===THREE.RGBEEncoding?THREE.RGBM16Encoding:a.encoding};a.encoding===THREE.RGBM16Encoding&&(a.magFilter=THREE.LinearFilter,a.minFilter=THREE.LinearFilter);this.CubeUVRenderTarget=new THREE.WebGLRenderTarget(c,c,a);this.CubeUVRenderTarget.texture.name=
"PMREMCubeUVPacker.cubeUv";this.CubeUVRenderTarget.texture.mapping=THREE.CubeUVReflectionMapping;this.camera=new THREE.OrthographicCamera(.5*-c,.5*c,.5*-c,.5*c,0,1E3);this.scene=new THREE.Scene;this.scene.add(this.camera);this.objects=[];a=[];a.push(new THREE.Vector2(0,0));a.push(new THREE.Vector2(1,0));a.push(new THREE.Vector2(2,0));a.push(new THREE.Vector2(0,1));a.push(new THREE.Vector2(1,1));a.push(new THREE.Vector2(2,1));var h=c,c=b[0].width,f=0,m=4;this.numLods=Math.log(b[0].width)/Math.log(2)-
2;for(var k=0;k<this.numLods;k++){var q=.5*(h-h/m);16<c&&(m*=2);for(var t=16<c?6:1,n=0,p=0,e=c,r=0;r<t;r++){for(var g=0;6>g;g++){var d=this.getShader();d.uniforms.envMap.value=this.cubeLods[k].texture;d.envMap=this.cubeLods[k].texture;d.uniforms.faceIndex.value=g;d.uniforms.mapSize.value=e;d=new THREE.Mesh(new THREE.PlaneGeometry(e,e,0),d);d.position.x=a[g].x*e-q+n;d.position.y=a[g].y*e-q+f+p;d.material.side=THREE.DoubleSide;this.scene.add(d);this.objects.push(d)}p+=1.75*e;n+=1.25*e;e/=2}f+=2*c;16<
c&&(c/=2)}};
THREE.PMREMCubeUVPacker.prototype={constructor:THREE.PMREMCubeUVPacker,update:function(b){var l=b.gammaInput,c=b.gammaOutput,a=b.toneMapping,h=b.toneMappingExposure,f=b.getRenderTarget();b.gammaInput=!1;b.gammaOutput=!1;b.toneMapping=THREE.LinearToneMapping;b.toneMappingExposure=1;b.render(this.scene,this.camera,this.CubeUVRenderTarget,!1);b.setRenderTarget(f);b.toneMapping=a;b.toneMappingExposure=h;b.gammaInput=l;b.gammaOutput=c},getShader:function(){return new THREE.ShaderMaterial({uniforms:{faceIndex:{value:0},mapSize:{value:0},
envMap:{value:null},testColor:{value:new THREE.Vector3(1,1,1)}},vertexShader:"precision highp float;\t\t\t\tvarying vec2 vUv;\t\t\t\tvoid main() {\t\t\t\t\tvUv \x3d uv;\t\t\t\t\tgl_Position \x3d projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\t\t\t\t}",fragmentShader:"precision highp float;\t\t\t\tvarying vec2 vUv;\t\t\t\tuniform samplerCube envMap;\t\t\t\tuniform float mapSize;\t\t\t\tuniform vec3 testColor;\t\t\t\tuniform int faceIndex;\t\t\t\t\t\t\t\tvoid main() {\t\t\t\t\tvec3 sampleDirection;\t\t\t\t\tvec2 uv \x3d vUv;\t\t\t\t\tuv \x3d uv * 2.0 - 1.0;\t\t\t\t\tuv.y *\x3d -1.0;\t\t\t\t\tif(faceIndex \x3d\x3d 0) {\t\t\t\t\t\tsampleDirection \x3d normalize(vec3(1.0, uv.y, -uv.x));\t\t\t\t\t} else if(faceIndex \x3d\x3d 1) {\t\t\t\t\t\tsampleDirection \x3d normalize(vec3(uv.x, 1.0, uv.y));\t\t\t\t\t} else if(faceIndex \x3d\x3d 2) {\t\t\t\t\t\tsampleDirection \x3d normalize(vec3(uv.x, uv.y, 1.0));\t\t\t\t\t} else if(faceIndex \x3d\x3d 3) {\t\t\t\t\t\tsampleDirection \x3d normalize(vec3(-1.0, uv.y, uv.x));\t\t\t\t\t} else if(faceIndex \x3d\x3d 4) {\t\t\t\t\t\tsampleDirection \x3d normalize(vec3(uv.x, -1.0, -uv.y));\t\t\t\t\t} else {\t\t\t\t\t\tsampleDirection \x3d normalize(vec3(-uv.x, uv.y, -1.0));\t\t\t\t\t}\t\t\t\t\tvec4 color \x3d envMapTexelToLinear( textureCube( envMap, sampleDirection ) );\t\t\t\t\tgl_FragColor \x3d linearToOutputTexel( color );\t\t\t\t}",
blending:THREE.CustomBlending,premultipliedAlpha:!1,blendSrc:THREE.OneFactor,blendDst:THREE.ZeroFactor,blendSrcAlpha:THREE.OneFactor,blendDstAlpha:THREE.ZeroFactor,blendEquation:THREE.AddEquation})}};