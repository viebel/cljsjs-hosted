THREE.WebGLDeferredRenderer=function(R){function S(a,b,e,n){var c=b[a.uuid];void 0===c&&(c=I(),c.material=e(a),b[a.uuid]=c);c.used=!0;n(c.material,a);x[c.material.uuid]=a;return c.material}function T(a,b,e){if(void 0!==a.material){if(Array.isArray(a.material))for(var n=0,c=a.material.length;n<c;n++)a.material[n]=b(a.material[n]);else a.material=b(a.material);a.onBeforeRender=e}}function U(a){if(void 0!==a.material)if(Array.isArray(a.material))for(var b=0,e=a.material.length;b<e;b++)a.material[b]=
x[a.material[b].uuid];else a.material=x[a.material.uuid]}function oa(a){T(a,pa,qa)}function pa(a){return S(a,p?ca:da,ra,sa)}function ra(a){a=p?THREE.ShaderDeferred.normalDepthShininess:THREE.ShaderDeferred.normalDepth;return new THREE.ShaderMaterial({uniforms:Object.assign({},a.uniforms),fragmentShader:a.fragmentShader,vertexShader:a.vertexShader,blending:THREE.NoBlending})}function sa(a,b){void 0!==b.skinning&&(a.skinning=b.skinning);void 0!==b.morphTargets&&(a.morphTargets=b.morphTargets);a.visible=
!0===b.visible?!b.transparent:!1}function qa(a,b,e,n,c,d){p&&(a=x[c.uuid],void 0!==a&&void 0!==a.shininess&&(c.uniforms.shininess.value=a.shininess))}function ta(a){T(a,ua,ea)}function ua(a){return S(a,fa,va,ga)}function va(a){var b=THREE.ShaderDeferred.color,b=new THREE.ShaderMaterial({uniforms:Object.assign({},b.uniforms),fragmentShader:b.fragmentShader,vertexShader:b.vertexShader,blending:THREE.NoBlending});void 0!==a.map&&(b.map=a.map);return b}function ga(a,b){void 0!==b.map&&(a.map=b.map);void 0!==
b.skinning&&(a.skinning=b.skinning);void 0!==b.morphTargets&&(a.morphTargets=b.morphTargets);a.visible=!0===b.visible?!b.transparent:!1}function ea(a,b,e,n,c,d){a=x[c.uuid];c=c.uniforms;var g;!0===a.isMeshBasicMaterial?b=a.color:(g=a.color,b=a.emissive);e=a.specular;n=a.shininess;a=a.map;void 0!==g&&c.diffuse.value.copy(g);void 0!==b&&c.emissive.value.copy(b);void 0!==e&&c.specular.value.copy(e);void 0!==n&&void 0!==c.shininess&&(c.shininess.value=n);void 0!==a&&(c.map.value=a)}function wa(a){T(a,
xa,ya)}function xa(a){return!0===a.transparent?x[a.uuid]=a:S(a,ha,za,Aa)}function za(a){var b=THREE.ShaderDeferred.reconstruction,b=new THREE.ShaderMaterial({uniforms:Object.assign({},b.uniforms),fragmentShader:b.fragmentShader,vertexShader:b.vertexShader,blending:THREE.NoBlending});void 0!==a.map&&(b.map=a.map);return b}function Aa(a,b){ga(a,b)}function ya(a,b,e,n,c,d){if(!0===c.transparent){var g=O[this.uuid];g&&g.call(this,a,b,e,n,c,d)}else ea(a,b,e,n,c,d),c.uniforms.samplerLight.value=v.renderTarget2.texture}
function Ba(a){if(void 0!==a.material)if(Array.isArray(a.material))for(var b=0,e=a.material.length;b<e;b++)void 0===y[a.material[b].uuid]&&(y[a.material[b].uuid]=a.material[b].visible,a.material[b].visible=a.material[b].transparent&&a.material[b].visible);else void 0===y[a.material.uuid]&&(y[a.material.uuid]=a.material.visible,a.material.visible=a.material.transparent&&a.material.visible)}function Ca(a){if(void 0!==a.material)if(Array.isArray(a.material))for(var b=0,e=a.material.length;b<e;b++)a.material[b].visible=
y[a.material[b].uuid];else a.material.visible=y[a.material.uuid]}function Da(){var a=THREE.ShaderDeferred.emissiveLight,a=new THREE.ShaderMaterial({uniforms:Object.assign({},a.uniforms),vertexShader:a.vertexShader,fragmentShader:a.fragmentShader,blending:THREE.NoBlending,depthWrite:!1}),b=new THREE.PlaneBufferGeometry(2,2),a=new THREE.Mesh(b,a);a.onBeforeRender=function(a,b,c,d,g,f){g.uniforms.samplerColor.value=D.renderTarget2.texture};return a}function Ea(a){return a.isPointLight?(a=V(a,new THREE.SphereGeometry(1,
16,8)),a.onBeforeRender=Fa,a):a.isSpotLight?(a=V(a,new THREE.PlaneBufferGeometry(2,2)),a.onBeforeRender=Ga,a):a.isDirectionalLight?(a=V(a,new THREE.PlaneBufferGeometry(2,2)),a.onBeforeRender=Ha,a):null}function Ia(a){return a.isPointLight?(a=W(p?THREE.ShaderDeferred.pointLightPre:THREE.ShaderDeferred.pointLight),a.side=THREE.BackSide,a.depthFunc=THREE.GreaterEqualDepth,a):a.isSpotLight?(a=W(p?THREE.ShaderDeferred.spotLightPre:THREE.ShaderDeferred.spotLight),a.depthTest=!1,a):a.isDirectionalLight?
(a=W(p?THREE.ShaderDeferred.directionalLightPre:THREE.ShaderDeferred.directionalLight),a.depthTest=!1,a):null}function V(a,b){var e=new THREE.Mesh(b,Ja);e.userData.originalLight=a;return e}function W(a){a=new THREE.ShaderMaterial({uniforms:Object.assign({},a.uniforms),vertexShader:a.vertexShader,fragmentShader:a.fragmentShader,transparent:!0,blending:THREE.AdditiveBlending,depthWrite:!1});p&&(a.premultipliedAlpha=!0);return a}function X(a){p?a.samplerNormalDepthShininess.value=E.renderTarget2.texture:
(a.samplerNormalDepth.value=E.renderTarget2.texture,a.samplerColor.value=D.renderTarget2.texture)}function Fa(a,b,e,n,c,d){a=this.userData.originalLight;b=a.distance;c=c.uniforms;c.lightColor.value.copy(a.color);0<b?(c.lightRadius.value=b,c.lightIntensity.value=a.intensity,c.lightPositionVS.value.setFromMatrixPosition(a.matrixWorld).applyMatrix4(J.matrixWorldInverse)):c.lightRadius.value=Infinity;X(c)}function Ga(a,b,e,d,c,f){a=this.userData.originalLight;b=this.material.uniforms;b.lightAngle.value=
a.angle;b.lightColor.value.copy(a.color);b.lightIntensity.value=a.intensity;b.lightPositionVS.value.setFromMatrixPosition(a.matrixWorld).applyMatrix4(J.matrixWorldInverse);e=b.lightDirectionVS.value;d=ia;e.setFromMatrixPosition(a.matrixWorld);d.setFromMatrixPosition(a.target.matrixWorld);e.sub(d).normalize().transformDirection(J.matrixWorldInverse);X(b)}function Ha(a,b,e,d,c,f){a=this.userData.originalLight;b=this.material.uniforms;b.lightColor.value.copy(a.color);b.lightIntensity.value=a.intensity;
e=b.lightDirectionVS.value;d=ia;e.setFromMatrixPosition(a.matrixWorld);d.setFromMatrixPosition(a.target.matrixWorld);e.sub(d).normalize().transformDirection(J.matrixWorldInverse);X(b)}function Ka(a){if(void 0!==a.material&&(O[a.uuid]=a.onBeforeRender,!z&&!p&&a.visible))if(Array.isArray(a.material))for(var b=0,e=a.material.length;b<e;b++){if(!0===a.material[b].visible&&!0===a.material[b].transparent){z=!0;break}}else!0===a.material.visible&&!0===a.material.transparent&&(z=!0)}function ja(a){void 0!==
a.material&&(a.onBeforeRender=O[a.uuid])}function ka(a){if(!0===a.isLight){var b=Y[a.uuid];void 0===b&&(b=I(),b.light=Ea(a),Y[a.uuid]=b);b.used=!0;b=b.light;if(null!==b){a=!0===a.isPointLight?F:G;var e=a.userData.lights;void 0===e[b.uuid]&&(a.add(b),e[b.uuid]={light:b,found:!0});e[b.uuid].found=!0}}}function P(a){for(var b=a.userData.lights,e=Object.keys(b),d=0,c=e.length;d<c;d++){var f=e[d];if(!1===b[f].found)a.remove(b[f].light),delete b[f];else{var g=b[f].light,k=g,h=g,m=p?la:ma,l=m[h.uuid];void 0===
l&&(l=I(),l.material=Ia(h.userData.originalLight),m[h.uuid]=l);l.used=!0;k.material=l.material;g.userData.originalLight.isPointLight&&(k=g.userData.originalLight,h=k.distance,0<h&&(g.scale.set(1,1,1).multiplyScalar(h),g.position.setFromMatrixPosition(k.matrixWorld)));b[f].found=!1}}}function I(){return{used:!0,keepAlive:na,count:0}}function w(a){for(var b=Object.keys(a),e=0,d=b.length;e<d;e++){var c=b[e];!1===a[c].used?(a[c].count++,!1===a[c].keepAlive&&60<a[c].count&&delete a[c]):(a[c].used=!1,a[c].count=
0)}}function Z(a){for(var b=Object.keys(a),e=0,d=b.length;e<d;e++)a[b[e]]=void 0}R=R||{};var d=this,f,k,h,D,K,m,t,L,M,E,v,B,N,C,H,q,l,u,J,F,G,Q=!1,z=!1,p=!1,na=!1,Ja=new THREE.ShaderMaterial({visible:!1}),ia=new THREE.Vector3,aa={},ba={},da={},ca={},fa={},ha={},Y={},ma={},la={},x={},O={},y={};this.domElement=this.renderer=void 0;this.forwardRendering=!1;this.setSize=function(a,b){k=a;h=b;this.renderer.setSize(k,h);E.setSize(k,h);D.setSize(k,h);v.setSize(k,h);L.setSize(k,h);B.setSize(k,h);u.image.width=
k;u.image.height=h;u.needsUpdate=!0;l.uniforms.resolution.value.set(1/k,1/h)};this.setAntialias=function(a){Q=a};this.enableLightPrePass=function(a){p=a;q.uniforms.samplerResult.value=p?L.renderTarget2.texture:v.renderTarget2.texture};this.render=function(a,b){if(this.forwardRendering)this.renderer.render(a,b);else{var e=a.autoUpdate,n=this.renderer.autoClearColor,c=this.renderer.autoClearDepth,u=this.renderer.autoClearStencil;J=b;var g=aa[a.uuid],r=ba[a.uuid];if(void 0===g){var A=new THREE.Scene;
A.userData.lights={};g=I();g.scene=A;aa[a.uuid]=g}void 0===r&&(A=new THREE.Scene,A.userData.lights={},r=Da(),A.userData.emissiveLight=r,A.add(r),r=I(),r.scene=A,ba[a.uuid]=r);g.used=!0;r.used=!0;g=g.scene;r=r.scene;r.userData.emissiveLight.visible=!p;F=g;G=r;a.autoUpdate=!1;a.updateMatrixWorld();z=!1;a.traverse(Ka);g=THREE.ShaderDeferredCommon.commonUniforms;g.viewWidth.value=k;g.viewHeight.value=h;g.matProjInverse.value.getInverse(b.projectionMatrix);a.traverse(oa);N.scene=a;N.camera=b;d.renderer.autoClearDepth=
!0;d.renderer.autoClearStencil=!0;f.enable(f.STENCIL_TEST);f.stencilFunc(f.ALWAYS,1,4294967295);f.stencilOp(f.REPLACE,f.REPLACE,f.REPLACE);E.render();a.traverse(U);p?(a.traverse(ka),P(F),P(G),C.scene=F,C.camera=b,H.scene=G,d.renderer.autoClearDepth=!1,d.renderer.autoClearStencil=!1,f.stencilFunc(f.EQUAL,1,4294967295),f.stencilOp(f.KEEP,f.KEEP,f.KEEP),v.render(),a.traverse(wa),M.scene=a,M.camera=b,d.renderer.autoClearDepth=!1,d.renderer.autoClearStencil=!1,L.render(),f.disable(f.STENCIL_TEST),a.traverse(U)):
(a.traverse(ta),K.scene=a,K.camera=b,d.renderer.autoClearDepth=!1,d.renderer.autoClearStencil=!1,f.stencilFunc(f.EQUAL,1,4294967295),f.stencilOp(f.KEEP,f.KEEP,f.KEEP),D.render(),a.traverse(U),a.traverse(ka),P(F),P(G),C.scene=F,C.camera=b,H.scene=G,d.renderer.autoClearDepth=!1,d.renderer.autoClearStencil=!1,v.render(),f.disable(f.STENCIL_TEST));!p&&z&&(a.traverse(Ba),a.traverse(ja),m.scene=a,m.camera=b);p?(m.renderToScreen=!1,m.enabled=!1,t.renderToScreen=!1,t.enabled=!1,Q?(q.renderToScreen=!1,l.renderToScreen=
!0,l.enabled=!0):(q.renderToScreen=!0,l.renderToScreen=!1,l.enabled=!1)):z?Q?(q.renderToScreen=!1,m.renderToScreen=!1,m.enabled=!0,t.renderToScreen=!1,t.enabled=!1,l.renderToScreen=!0,l.enabled=!0):(q.renderToScreen=!1,m.renderToScreen=!1,m.enabled=!0,t.renderToScreen=!0,t.enabled=!0,l.renderToScreen=!1,l.enabled=!1):Q?(q.renderToScreen=!1,m.renderToScreen=!1,m.enabled=!1,t.renderToScreen=!1,t.enabled=!1,l.renderToScreen=!0,l.enabled=!0):(q.renderToScreen=!0,m.renderToScreen=!1,m.enabled=!1,t.renderToScreen=
!1,t.enabled=!1,l.renderToScreen=!1,l.enabled=!1);d.renderer.autoClearDepth=!1;d.renderer.autoClearStencil=!1;B.render();!p&&z&&a.traverse(Ca);a.traverse(ja);w(aa);w(ba);w(da);w(ca);w(fa);w(ha);w(ma);w(la);w(Y);Z(x);Z(O);Z(y);a.autoUpdate=e;this.renderer.autoClearColor=n;this.renderer.autoClearDepth=c;this.renderer.autoClearStencil=u}};(function(a){d.renderer=void 0!==a.renderer?a.renderer:new THREE.WebGLRenderer;d.domElement=d.renderer.domElement;f=d.renderer.context;k=void 0!==a.width?a.width:d.renderer.getSize().width;
h=void 0!==a.height?a.height:d.renderer.getSize().height;var b=void 0!==a.antialias?a.antialias:!1;void 0!==a.cacheKeepAlive&&(na=a.cacheKeepAlive);u=new THREE.DepthTexture(k,h,THREE.UnsignedInt248Type,void 0,void 0,void 0,void 0,void 0,void 0,THREE.DepthStencilFormat);N=new THREE.RenderPass;N.clear=!0;a=new THREE.WebGLRenderTarget(k,h,{minFilter:THREE.NearestFilter,magFilter:THREE.NearestFilter,format:THREE.RGBAFormat,type:THREE.FloatType,stencilBuffer:!0,depthTexture:u});a.texture.generateMipamps=
!1;E=new THREE.EffectComposer(d.renderer,a);E.addPass(N);K=new THREE.RenderPass;K.clear=!0;a=new THREE.WebGLRenderTarget(k,h,{minFilter:THREE.NearestFilter,magFilter:THREE.NearestFilter,format:THREE.RGBAFormat,type:THREE.FloatType,depthTexture:u});a.texture.generateMipamps=!1;D=new THREE.EffectComposer(d.renderer,a);D.addPass(K);H=new THREE.RenderPass;H.clear=!0;H.camera=new THREE.OrthographicCamera(-1,1,1,-1,0,1);C=new THREE.RenderPass;C.clear=!1;a=new THREE.WebGLRenderTarget(k,h,{minFilter:THREE.NearestFilter,
magFilter:THREE.NearestFilter,format:THREE.RGBAFormat,type:THREE.FloatType,depthTexture:u});a.texture.generateMipamps=!1;v=new THREE.EffectComposer(d.renderer,a);v.addPass(H);v.addPass(C);M=new THREE.RenderPass;M.clear=!0;a=new THREE.WebGLRenderTarget(k,h,{minFilter:THREE.NearestFilter,magFilter:THREE.NearestFilter,format:THREE.RGBAFormat,type:THREE.FloatType,depthTexture:u});a.texture.generateMipamps=!1;L=new THREE.EffectComposer(d.renderer,a);L.addPass(M);q=new THREE.ShaderPass(THREE.ShaderDeferred["final"]);
q.clear=!0;q.uniforms.samplerResult.value=v.renderTarget2.texture;q.material.blending=THREE.NoBlending;q.material.depthWrite=!1;q.material.depthTest=!1;m=new THREE.RenderPass;m.clear=!1;t=new THREE.ShaderPass(THREE.CopyShader);l=new THREE.ShaderPass(THREE.FXAAShader);a=new THREE.WebGLRenderTarget(k,h,{minFilter:THREE.NearestFilter,magFilter:THREE.LinearFilter,format:THREE.RGBFormat,type:THREE.UnsignedByteType,depthTexture:u});a.texture.generateMipamps=!1;B=new THREE.EffectComposer(d.renderer,a);B.addPass(q);
B.addPass(m);B.addPass(t);B.addPass(l);d.setSize(k,h);d.setAntialias(b);d.enableLightPrePass(!1)})(R)};
THREE.DeferredShaderChunk={packVector3:"float vec3_to_float( vec3 data ) {\n\tconst float unit \x3d 255.0/256.0;\n\thighp float compressed \x3d fract( data.x * unit ) + floor( data.y * unit * 255.0 ) + floor( data.z * unit * 255.0 ) * 255.0;\n\treturn compressed;\n}",unpackFloat:"vec3 float_to_vec3( float data ) {\n\tconst float unit \x3d 255.0;\n\tvec3 uncompressed;\n\tuncompressed.x \x3d fract( data );\n\tfloat zInt \x3d floor( data / unit );\n\tuncompressed.z \x3d fract( zInt / unit );\n\tuncompressed.y \x3d fract( floor( data - ( zInt * unit ) ) / unit );\n\treturn uncompressed;\n}",packNormal:"vec2 normal_to_vec2( vec3 normal ) {\n\treturn normal.xy / sqrt( normal.z * 8.0 + 8.0 ) + 0.5;\n}",
unpackVector2:"vec3 vec2_to_normal( vec2 data ) {\n\tvec2 fenc \x3d data * 4.0 - 2.0;\n\tfloat f \x3d dot( fenc, fenc );\n\tfloat g \x3d sqrt( 1.0 - f / 4.0 );\n\tvec3 normal;\n\tnormal.xy \x3d fenc * g;\n\tnormal.z \x3d 1.0 - f / 2.0;\n\treturn normal;\n}",computeTextureCoord:"vec2 texCoord \x3d gl_FragCoord.xy / vec2( viewWidth, viewHeight );",packNormalDepth:"vec4 packedNormalDepth;\npackedNormalDepth.xyz \x3d normal * 0.5 + 0.5;\npackedNormalDepth.w \x3d position.z / position.w;",unpackNormalDepth:"vec4 normalDepthMap \x3d texture2D( samplerNormalDepth, texCoord );\nfloat depth \x3d normalDepthMap.w;\nif ( depth \x3d\x3d 0.0 ) discard;\nvec3 normal \x3d normalDepthMap.xyz * 2.0 - 1.0;",
packNormalDepthShininess:"vec4 packedNormalDepthShininess;\npackedNormalDepthShininess.xy \x3d normal_to_vec2( normal );\npackedNormalDepthShininess.z \x3d shininess;\npackedNormalDepthShininess.w \x3d position.z / position.w;",unpackNormalDepthShininess:"vec4 normalDepthMap \x3d texture2D( samplerNormalDepthShininess, texCoord );\nfloat depth \x3d normalDepthMap.w;\nif ( depth \x3d\x3d 0.0 ) discard;\nvec3 normal \x3d vec2_to_normal( normalDepthMap.xy );\nfloat shininess \x3d normalDepthMap.z;",
packColor:"vec4 packedColor;\npackedColor.x \x3d vec3_to_float( diffuseColor.rgb );\npackedColor.y \x3d vec3_to_float( emissiveColor );\npackedColor.z \x3d vec3_to_float( specularColor );\npackedColor.w \x3d shininess;",unpackColor:"vec4 colorMap \x3d texture2D( samplerColor, texCoord );\nvec3 diffuseColor \x3d float_to_vec3( colorMap.x );\nvec3 emissiveColor \x3d float_to_vec3( colorMap.y );\nvec3 specularColor \x3d float_to_vec3( colorMap.z );\nfloat shininess \x3d colorMap.w;",packLight:"vec4 packedLight;\npackedLight.xyz \x3d lightIntensity * lightColor * max( dot( lightVector, normal ), 0.0 ) * attenuation;\npackedLight.w \x3d lightIntensity * specular * max( dot( lightVector, normal ), 0.0 ) * attenuation;",
computeVertexPositionVS:"vec2 xy \x3d texCoord * 2.0 - 1.0;\nvec4 vertexPositionProjected \x3d vec4( xy, depth, 1.0 );\nvec4 vertexPositionVS \x3d matProjInverse * vertexPositionProjected;\nvertexPositionVS.xyz /\x3d vertexPositionVS.w;\nvertexPositionVS.w \x3d 1.0;",computeSpecular:"vec3 halfVector \x3d normalize( lightVector - normalize( vertexPositionVS.xyz ) );\nfloat dotNormalHalf \x3d max( dot( normal, halfVector ), 0.0 );\nfloat specular \x3d 0.31830988618 * ( shininess * 0.5 + 1.0 ) * pow( dotNormalHalf, shininess );",
combine:"gl_FragColor \x3d vec4( lightIntensity * lightColor * max( dot( lightVector, normal ), 0.0 ) * ( diffuseColor + specular * specularColor ) * attenuation, 1.0 );"};THREE.ShaderDeferredCommon={commonUniforms:{matProjInverse:new THREE.Uniform(new THREE.Matrix4),viewWidth:new THREE.Uniform(800),viewHeight:new THREE.Uniform(600)}};
THREE.ShaderDeferred={normalDepth:{uniforms:{},vertexShader:"varying vec3 vNormal;\nvarying vec4 vPosition;\n#include \x3cmorphtarget_pars_vertex\x3e\n#include \x3cskinning_pars_vertex\x3e\nvoid main() {\n#include \x3cbegin_vertex\x3e\n#include \x3cbeginnormal_vertex\x3e\n#include \x3cskinbase_vertex\x3e\n#include \x3cskinnormal_vertex\x3e\n#include \x3cdefaultnormal_vertex\x3e\n#include \x3cmorphtarget_vertex\x3e\n#include \x3cskinning_vertex\x3e\n#include \x3cproject_vertex\x3e\n\tvNormal \x3d normalize( transformedNormal );\n\tvPosition \x3d gl_Position;\n}",fragmentShader:["varying vec3 vNormal;\nvarying vec4 vPosition;\nvoid main() {\n\tvec3 normal \x3d vNormal;\n\tvec4 position \x3d vPosition;",
THREE.DeferredShaderChunk.packNormalDepth,"\tgl_FragColor \x3d packedNormalDepth;\n}"].join("\n")},color:{uniforms:{map:new THREE.Uniform(null),offsetRepeat:new THREE.Uniform(new THREE.Vector4(0,0,1,1)),diffuse:new THREE.Uniform(new THREE.Color(0)),emissive:new THREE.Uniform(new THREE.Color(0)),specular:new THREE.Uniform(new THREE.Color(0)),shininess:new THREE.Uniform(30)},vertexShader:"#include \x3cuv_pars_vertex\x3e\n#include \x3cmorphtarget_pars_vertex\x3e\n#include \x3cskinning_pars_vertex\x3e\nvoid main() {\n#include \x3cuv_vertex\x3e\n#include \x3cbegin_vertex\x3e\n#include \x3cbeginnormal_vertex\x3e\n#include \x3cskinbase_vertex\x3e\n#include \x3cskinnormal_vertex\x3e\n#include \x3cdefaultnormal_vertex\x3e\n#include \x3cmorphtarget_vertex\x3e\n#include \x3cskinning_vertex\x3e\n#include \x3cproject_vertex\x3e\n}",
fragmentShader:["uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\n#include \x3cuv_pars_fragment\x3e\n#include \x3cmap_pars_fragment\x3e",THREE.DeferredShaderChunk.packVector3,"void main() {\n\tvec4 diffuseColor \x3d vec4( diffuse, 1.0 );\n\tvec3 emissiveColor \x3d emissive;\n\tvec3 specularColor \x3d specular;\n#include \x3cmap_fragment\x3e",THREE.DeferredShaderChunk.packColor,"\tgl_FragColor \x3d packedColor;\n}"].join("\n")},emissiveLight:{uniforms:Object.assign({samplerColor:new THREE.Uniform(null)},
THREE.ShaderDeferredCommon.commonUniforms),vertexShader:"void main() { \n\tgl_Position \x3d vec4( sign( position.xy ), 0.0, 1.0 );\n}",fragmentShader:["uniform sampler2D samplerColor;\nuniform float viewHeight;\nuniform float viewWidth;",THREE.DeferredShaderChunk.unpackFloat,"void main() {",THREE.DeferredShaderChunk.computeTextureCoord,THREE.DeferredShaderChunk.unpackColor,"\tgl_FragColor \x3d vec4( emissiveColor, 1.0 );\n}"].join("\n")},pointLight:{uniforms:Object.assign({samplerNormalDepth:new THREE.Uniform(null),
samplerColor:new THREE.Uniform(null),lightColor:new THREE.Uniform(new THREE.Color(0)),lightPositionVS:new THREE.Uniform(new THREE.Vector3(0,1,0)),lightIntensity:new THREE.Uniform(1),lightRadius:new THREE.Uniform(1)},THREE.ShaderDeferredCommon.commonUniforms),vertexShader:"void main() {\n\tgl_Position \x3d projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",fragmentShader:["uniform sampler2D samplerNormalDepth;\nuniform sampler2D samplerColor;\nuniform float viewHeight;\nuniform float viewWidth;\nuniform vec3 lightColor;\nuniform vec3 lightPositionVS;\nuniform float lightIntensity;\nuniform float lightRadius;\nuniform mat4 matProjInverse;",
THREE.DeferredShaderChunk.unpackFloat,"void main() {",THREE.DeferredShaderChunk.computeTextureCoord,THREE.DeferredShaderChunk.unpackNormalDepth,THREE.DeferredShaderChunk.computeVertexPositionVS,"\tvec3 lightVector \x3d lightPositionVS - vertexPositionVS.xyz;\n\tfloat distance \x3d length( lightVector );\n\tif ( distance \x3e lightRadius ) discard;\n\tlightVector \x3d normalize( lightVector );",THREE.DeferredShaderChunk.unpackColor,THREE.DeferredShaderChunk.computeSpecular,"\t//float cutoff \x3d 0.3;\n\t//float denom \x3d distance / lightRadius + 1.0;\n\t//float attenuation \x3d 1.0 / ( denom * denom );\n\t//attenuation \x3d ( attenuation - cutoff ) / ( 1.0 - cutoff );\n\t//attenuation \x3d max( attenuation, 0.0 );\n\t//attenuation *\x3d attenuation;\n\t//diffuseColor *\x3d saturate( -distance / lightRadius + 1.0 );\n\t//float attenuation \x3d 1.0;\n\tfloat attenuation \x3d saturate( -distance / lightRadius + 1.0 );",
THREE.DeferredShaderChunk.combine,"}"].join("\n")},spotLight:{uniforms:Object.assign({samplerNormalDepth:new THREE.Uniform(null),samplerColor:new THREE.Uniform(null),lightColor:new THREE.Uniform(new THREE.Color(0)),lightDirectionVS:new THREE.Uniform(new THREE.Vector3(0,1,0)),lightPositionVS:new THREE.Uniform(new THREE.Vector3(0,1,0)),lightAngle:new THREE.Uniform(1),lightIntensity:new THREE.Uniform(1)},THREE.ShaderDeferredCommon.commonUniforms),vertexShader:"void main() { \n\tgl_Position \x3d vec4( sign( position.xy ), 0.0, 1.0 );\n}",
fragmentShader:["uniform sampler2D samplerNormalDepth;\nuniform sampler2D samplerColor;\nuniform float viewHeight;\nuniform float viewWidth;\nuniform vec3 lightColor;\nuniform vec3 lightPositionVS;\nuniform vec3 lightDirectionVS;\nuniform float lightAngle;\nuniform float lightIntensity;\nuniform mat4 matProjInverse;",THREE.DeferredShaderChunk.unpackFloat,"void main() {",THREE.DeferredShaderChunk.computeTextureCoord,THREE.DeferredShaderChunk.unpackNormalDepth,THREE.DeferredShaderChunk.computeVertexPositionVS,
THREE.DeferredShaderChunk.unpackColor,"\tvec3 lightVector \x3d normalize( lightPositionVS.xyz - vertexPositionVS.xyz );\n\tfloat rho \x3d dot( lightDirectionVS, lightVector );\n\tfloat rhoMax \x3d cos( lightAngle );\n\tif ( rho \x3c\x3d rhoMax ) discard;\n\tfloat theta \x3d rhoMax + 0.0001;\n\tfloat phi \x3d rhoMax + 0.05;\n\tfloat falloff \x3d 4.0;\n\tfloat spot \x3d 0.0;\n\tif ( rho \x3e\x3d phi ) {\n\t\tspot \x3d 1.0;\n\t} else if ( rho \x3c\x3d theta ) {\n\t\tspot \x3d 0.0;\n\t} else { \n\t\tspot \x3d pow( ( rho - theta ) / ( phi - theta ), falloff );\n\t}\n\tdiffuseColor *\x3d spot;",
THREE.DeferredShaderChunk.computeSpecular,"\tconst float attenuation \x3d 1.0;",THREE.DeferredShaderChunk.combine,"}"].join("\n")},directionalLight:{uniforms:Object.assign({samplerNormalDepth:new THREE.Uniform(null),samplerColor:new THREE.Uniform(null),lightColor:new THREE.Uniform(new THREE.Color(0)),lightDirectionVS:new THREE.Uniform(new THREE.Vector3(0,1,0)),lightIntensity:new THREE.Uniform(1)},THREE.ShaderDeferredCommon.commonUniforms),vertexShader:"void main() { \n\tgl_Position \x3d vec4( sign( position.xy ), 0.0, 1.0 );\n}",
fragmentShader:["uniform sampler2D samplerNormalDepth;\nuniform sampler2D samplerColor;\nuniform float viewHeight;\nuniform float viewWidth;\nuniform vec3 lightColor;\nuniform vec3 lightDirectionVS;\nuniform float lightIntensity;\nuniform mat4 matProjInverse;",THREE.DeferredShaderChunk.unpackFloat,"void main() {",THREE.DeferredShaderChunk.computeTextureCoord,THREE.DeferredShaderChunk.unpackNormalDepth,THREE.DeferredShaderChunk.computeVertexPositionVS,THREE.DeferredShaderChunk.unpackColor,"\tvec3 lightVector \x3d normalize( lightDirectionVS );",
THREE.DeferredShaderChunk.computeSpecular,"\tconst float attenuation \x3d 1.0;",THREE.DeferredShaderChunk.combine,"}"].join("\n")},normalDepthShininess:{uniforms:{shininess:new THREE.Uniform(30)},vertexShader:"varying vec3 vNormal;\nvarying vec4 vPosition;\n#include \x3cmorphtarget_pars_vertex\x3e\n#include \x3cskinning_pars_vertex\x3e\nvoid main() {\n#include \x3cbegin_vertex\x3e\n#include \x3cbeginnormal_vertex\x3e\n#include \x3cskinbase_vertex\x3e\n#include \x3cskinnormal_vertex\x3e\n#include \x3cdefaultnormal_vertex\x3e\n#include \x3cmorphtarget_vertex\x3e\n#include \x3cskinning_vertex\x3e\n#include \x3cproject_vertex\x3e\n\tvNormal \x3d normalize( transformedNormal );\n\tvPosition \x3d gl_Position;\n}",
fragmentShader:["varying vec3 vNormal;\nvarying vec4 vPosition;\nuniform float shininess;",THREE.DeferredShaderChunk.packNormal,"void main() {\n\tvec3 normal \x3d vNormal;\n\tvec4 position \x3d vPosition;",THREE.DeferredShaderChunk.packNormalDepthShininess,"\tgl_FragColor \x3d packedNormalDepthShininess;\n}"].join("\n")},pointLightPre:{uniforms:Object.assign({samplerNormalDepthShininess:new THREE.Uniform(null),lightColor:new THREE.Uniform(new THREE.Color(0)),lightPositionVS:new THREE.Uniform(new THREE.Vector3(0,
1,0)),lightIntensity:new THREE.Uniform(1),lightRadius:new THREE.Uniform(1)},THREE.ShaderDeferredCommon.commonUniforms),vertexShader:"void main() {\n\tgl_Position \x3d projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",fragmentShader:["uniform sampler2D samplerNormalDepthShininess;\nuniform float viewHeight;\nuniform float viewWidth;\nuniform vec3 lightColor;\nuniform vec3 lightPositionVS;\nuniform float lightIntensity;\nuniform float lightRadius;\nuniform mat4 matProjInverse;",THREE.DeferredShaderChunk.unpackFloat,
THREE.DeferredShaderChunk.unpackVector2,"void main() {",THREE.DeferredShaderChunk.computeTextureCoord,THREE.DeferredShaderChunk.unpackNormalDepthShininess,THREE.DeferredShaderChunk.computeVertexPositionVS,"\tvec3 lightVector \x3d lightPositionVS - vertexPositionVS.xyz;\n\tfloat distance \x3d length( lightVector );\n\tif ( distance \x3e lightRadius ) discard;\n\tlightVector \x3d normalize( lightVector );",THREE.DeferredShaderChunk.computeSpecular,"\tfloat attenuation \x3d saturate( -distance / lightRadius + 1.0 );",
THREE.DeferredShaderChunk.packLight,"\tgl_FragColor \x3d packedLight;\n}"].join("\n")},spotLightPre:{uniforms:Object.assign({samplerNormalDepthShininess:new THREE.Uniform(null),lightColor:new THREE.Uniform(new THREE.Color(0)),lightDirectionVS:new THREE.Uniform(new THREE.Vector3(0,1,0)),lightPositionVS:new THREE.Uniform(new THREE.Vector3(0,1,0)),lightAngle:new THREE.Uniform(1),lightIntensity:new THREE.Uniform(1)},THREE.ShaderDeferredCommon.commonUniforms),vertexShader:"void main() { \n\tgl_Position \x3d vec4( sign( position.xy ), 0.0, 1.0 );\n}",
fragmentShader:["uniform sampler2D samplerNormalDepthShininess;\nuniform float viewHeight;\nuniform float viewWidth;\nuniform vec3 lightColor;\nuniform vec3 lightPositionVS;\nuniform vec3 lightDirectionVS;\nuniform float lightAngle;\nuniform float lightIntensity;\nuniform mat4 matProjInverse;",THREE.DeferredShaderChunk.unpackFloat,THREE.DeferredShaderChunk.unpackVector2,"void main() {",THREE.DeferredShaderChunk.computeTextureCoord,THREE.DeferredShaderChunk.unpackNormalDepthShininess,THREE.DeferredShaderChunk.computeVertexPositionVS,
"\tvec3 lightVector \x3d normalize( lightPositionVS.xyz - vertexPositionVS.xyz );\n\tfloat rho \x3d dot( lightDirectionVS, lightVector );\n\tfloat rhoMax \x3d cos( lightAngle );\n\tif ( rho \x3c\x3d rhoMax ) discard;\n\tfloat theta \x3d rhoMax + 0.0001;\n\tfloat phi \x3d rhoMax + 0.05;\n\tfloat falloff \x3d 4.0;\n\tfloat spot \x3d 0.0;\n\tif ( rho \x3e\x3d phi ) {\n\t\tspot \x3d 1.0;\n\t} else if ( rho \x3c\x3d theta ) {\n\t\tspot \x3d 0.0;\n\t} else { \n\t\tspot \x3d pow( ( rho - theta ) / ( phi - theta ), falloff );\n\t}",
THREE.DeferredShaderChunk.computeSpecular,"\tconst float attenuation \x3d 1.0;",THREE.DeferredShaderChunk.packLight,"\tgl_FragColor \x3d spot * packedLight;\n}"].join("\n")},directionalLightPre:{uniforms:Object.assign({samplerNormalDepthShininess:new THREE.Uniform(null),lightColor:new THREE.Uniform(new THREE.Color(0)),lightDirectionVS:new THREE.Uniform(new THREE.Vector3(0,1,0)),lightIntensity:new THREE.Uniform(1)},THREE.ShaderDeferredCommon.commonUniforms),vertexShader:"void main() { \n\tgl_Position \x3d vec4( sign( position.xy ), 0.0, 1.0 );\n}",
fragmentShader:["uniform sampler2D samplerNormalDepthShininess;\nuniform float viewHeight;\nuniform float viewWidth;\nuniform vec3 lightColor;\nuniform vec3 lightDirectionVS;\nuniform float lightIntensity;\nuniform mat4 matProjInverse;",THREE.DeferredShaderChunk.unpackFloat,THREE.DeferredShaderChunk.unpackVector2,"void main() {",THREE.DeferredShaderChunk.computeTextureCoord,THREE.DeferredShaderChunk.unpackNormalDepthShininess,THREE.DeferredShaderChunk.computeVertexPositionVS,"\tvec3 lightVector \x3d normalize( lightDirectionVS );",
THREE.DeferredShaderChunk.computeSpecular,"\tconst float attenuation \x3d 1.0;",THREE.DeferredShaderChunk.packLight,"\tgl_FragColor \x3d packedLight;\n}"].join("\n")},reconstruction:{uniforms:Object.assign({samplerLight:new THREE.Uniform(null),map:new THREE.Uniform(null),offsetRepeat:new THREE.Uniform(new THREE.Vector4(0,0,1,1)),diffuse:new THREE.Uniform(new THREE.Color(0)),emissive:new THREE.Uniform(new THREE.Color(0)),specular:new THREE.Uniform(new THREE.Color(0)),shininess:new THREE.Uniform(30)},
THREE.ShaderDeferredCommon.commonUniforms),vertexShader:"#include \x3cuv_pars_vertex\x3e\n#include \x3cmorphtarget_pars_vertex\x3e\n#include \x3cskinning_pars_vertex\x3e\nvoid main() {\n#include \x3cuv_vertex\x3e\n#include \x3cbegin_vertex\x3e\n#include \x3cbeginnormal_vertex\x3e\n#include \x3cskinbase_vertex\x3e\n#include \x3cskinnormal_vertex\x3e\n#include \x3cdefaultnormal_vertex\x3e\n#include \x3cmorphtarget_vertex\x3e\n#include \x3cskinning_vertex\x3e\n#include \x3cproject_vertex\x3e\n}",fragmentShader:["uniform sampler2D samplerLight;\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float viewHeight;\nuniform float viewWidth;\n#include \x3cuv_pars_fragment\x3e\n#include \x3cmap_pars_fragment\x3e",
THREE.DeferredShaderChunk.unpackFloat,"void main() {\n\tvec4 diffuseColor \x3d vec4( diffuse, 1.0 );\n\tvec3 emissiveColor \x3d emissive;\n\tvec3 specularColor \x3d specular;",THREE.DeferredShaderChunk.computeTextureCoord,"\tvec4 light \x3d texture2D( samplerLight, texCoord );\n#include \x3cmap_fragment\x3e\n\tvec3 diffuseFinal \x3d diffuseColor.rgb * light.rgb;\n\tvec3 emissiveFinal \x3d emissiveColor;\n\tvec3 specularFinal \x3d specularColor * light.rgb * light.a;\n\tgl_FragColor \x3d vec4( diffuseFinal + emissiveFinal + specularFinal, 1.0 );\n}"].join("\n")},
final:{uniforms:{samplerResult:new THREE.Uniform(null)},vertexShader:"varying vec2 texCoord;\nvoid main() {\n\tvec4 pos \x3d vec4( sign( position.xy ), 0.0, 1.0 );\n\ttexCoord \x3d pos.xy * vec2( 0.5 ) + 0.5;\n\tgl_Position \x3d pos;\n}",fragmentShader:"varying vec2 texCoord;\nuniform sampler2D samplerResult;\nvoid main() {\n\tgl_FragColor \x3d texture2D( samplerResult, texCoord );\n}"}};