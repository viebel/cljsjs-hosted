THREE.Water=function(e,a){THREE.Mesh.call(this,e);this.type="Water";var d=this;a=a||{};var t=void 0!==a.color?new THREE.Color(a.color):new THREE.Color(16777215),n=a.textureWidth||512,p=a.textureHeight||512,q=a.clipBias||0,u=a.flowDirection||new THREE.Vector2(1,0),v=a.flowSpeed||.03,w=a.reflectivity||.02,x=a.scale||1,l=a.shader||THREE.Water.WaterShader,c=new THREE.TextureLoader,r=a.flowMap||void 0,m=a.normalMap0||c.load("textures/water/Water_1_M_Normal.jpg"),c=a.normalMap1||c.load("textures/water/Water_2_M_Normal.jpg"),
f=new THREE.Matrix4,y=new THREE.Clock;if(void 0===THREE.Reflector)console.error("THREE.Water: Required component THREE.Reflector not found.");else if(void 0===THREE.Refractor)console.error("THREE.Water: Required component THREE.Refractor not found.");else{var g=new THREE.Reflector(e,{textureWidth:n,textureHeight:p,clipBias:q}),h=new THREE.Refractor(e,{textureWidth:n,textureHeight:p,clipBias:q});g.matrixAutoUpdate=!1;h.matrixAutoUpdate=!1;this.material=new THREE.ShaderMaterial({uniforms:THREE.UniformsUtils.merge([THREE.UniformsLib.fog,
l.uniforms]),vertexShader:l.vertexShader,fragmentShader:l.fragmentShader,transparent:!0,fog:!0});void 0!==r?(this.material.defines.USE_FLOWMAP="",this.material.uniforms.tFlowMap={type:"t",value:r}):this.material.uniforms.flowDirection={type:"v2",value:u};m.wrapS=m.wrapT=THREE.RepeatWrapping;c.wrapS=c.wrapT=THREE.RepeatWrapping;this.material.uniforms.tReflectionMap.value=g.getRenderTarget().texture;this.material.uniforms.tRefractionMap.value=h.getRenderTarget().texture;this.material.uniforms.tNormalMap0.value=
m;this.material.uniforms.tNormalMap1.value=c;this.material.uniforms.color.value=t;this.material.uniforms.reflectivity.value=w;this.material.uniforms.textureMatrix.value=f;this.material.uniforms.config.value.x=0;this.material.uniforms.config.value.y=.075;this.material.uniforms.config.value.z=.075;this.material.uniforms.config.value.w=x;this.onBeforeRender=function(a,c,k){f.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1);f.multiply(k.projectionMatrix);f.multiply(k.matrixWorldInverse);f.multiply(d.matrixWorld);
var e=y.getDelta(),b=d.material.uniforms.config;b.value.x+=v*e;b.value.y=b.value.x+.075;.15<=b.value.x?(b.value.x=0,b.value.y=.075):.15<=b.value.y&&(b.value.y-=.15);d.visible=!1;g.matrixWorld.copy(d.matrixWorld);h.matrixWorld.copy(d.matrixWorld);g.onBeforeRender(a,c,k);h.onBeforeRender(a,c,k);d.visible=!0}}};THREE.Water.prototype=Object.create(THREE.Mesh.prototype);THREE.Water.prototype.constructor=THREE.Water;
THREE.Water.WaterShader={uniforms:{color:{type:"c",value:null},reflectivity:{type:"f",value:0},tReflectionMap:{type:"t",value:null},tRefractionMap:{type:"t",value:null},tNormalMap0:{type:"t",value:null},tNormalMap1:{type:"t",value:null},textureMatrix:{type:"m4",value:null},config:{type:"v4",value:new THREE.Vector4}},vertexShader:"#include \x3cfog_pars_vertex\x3e\nuniform mat4 textureMatrix;\nvarying vec4 vCoord;\nvarying vec2 vUv;\nvarying vec3 vToEye;\nvoid main() {\n\tvUv \x3d uv;\n\tvCoord \x3d textureMatrix * vec4( position, 1.0 );\n\tvec4 worldPosition \x3d modelMatrix * vec4( position, 1.0 );\n\tvToEye \x3d cameraPosition - worldPosition.xyz;\n\tvec4 mvPosition \x3d  viewMatrix * worldPosition;\n\tgl_Position \x3d projectionMatrix * mvPosition;\n\t#include \x3cfog_vertex\x3e\n}",
fragmentShader:"#include \x3cfog_pars_fragment\x3e\nuniform sampler2D tReflectionMap;\nuniform sampler2D tRefractionMap;\nuniform sampler2D tNormalMap0;\nuniform sampler2D tNormalMap1;\n#ifdef USE_FLOWMAP\n\tuniform sampler2D tFlowMap;\n#else\n\tuniform vec2 flowDirection;\n#endif\nuniform vec3 color;\nuniform float reflectivity;\nuniform vec4 config;\nvarying vec4 vCoord;\nvarying vec2 vUv;\nvarying vec3 vToEye;\nvoid main() {\n\tfloat flowMapOffset0 \x3d config.x;\n\tfloat flowMapOffset1 \x3d config.y;\n\tfloat halfCycle \x3d config.z;\n\tfloat scale \x3d config.w;\n\tvec3 toEye \x3d normalize( vToEye );\n\tvec2 flow;\n\t#ifdef USE_FLOWMAP\n\t\tflow \x3d texture2D( tFlowMap, vUv ).rg * 2.0 - 1.0;\n\t#else\n\t\tflow \x3d flowDirection;\n\t#endif\n\tflow.x *\x3d - 1.0;\n\tvec4 normalColor0 \x3d texture2D( tNormalMap0, ( vUv * scale ) + flow * flowMapOffset0 );\n\tvec4 normalColor1 \x3d texture2D( tNormalMap1, ( vUv * scale ) + flow * flowMapOffset1 );\n\tfloat flowLerp \x3d abs( halfCycle - flowMapOffset0 ) / halfCycle;\n\tvec4 normalColor \x3d mix( normalColor0, normalColor1, flowLerp );\n\tvec3 normal \x3d normalize( vec3( normalColor.r * 2.0 - 1.0, normalColor.b,  normalColor.g * 2.0 - 1.0 ) );\n\tfloat theta \x3d max( dot( toEye, normal ), 0.0 );\n\tfloat reflectance \x3d reflectivity + ( 1.0 - reflectivity ) * pow( ( 1.0 - theta ), 5.0 );\n\tvec3 coord \x3d vCoord.xyz / vCoord.w;\n\tvec2 uv \x3d coord.xy + coord.z * normal.xz * 0.05;\n\tvec4 reflectColor \x3d texture2D( tReflectionMap, vec2( 1.0 - uv.x, uv.y ) );\n\tvec4 refractColor \x3d texture2D( tRefractionMap, uv );\n\tgl_FragColor \x3d vec4( color, 1.0 ) * mix( refractColor, reflectColor, reflectance );\n\t#include \x3ctonemapping_fragment\x3e\n\t#include \x3cencodings_fragment\x3e\n\t#include \x3cfog_fragment\x3e\n}"};