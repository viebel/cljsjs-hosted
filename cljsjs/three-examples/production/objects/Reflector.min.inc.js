THREE.Reflector=function(A,a){THREE.Mesh.call(this,A);this.type="Reflector";var m=this;a=a||{};var B=void 0!==a.color?new THREE.Color(a.color):new THREE.Color(8355711),f=a.textureWidth||512,z=a.textureHeight||512,C=a.clipBias||0,n=a.shader||THREE.Reflector.ReflectorShader,D=void 0!==a.recursion?a.recursion:0,k=new THREE.Plane,h=new THREE.Vector3,l=new THREE.Vector3,y=new THREE.Vector3,p=new THREE.Matrix4,v=new THREE.Vector3(0,0,-1),g=new THREE.Vector4,q=new THREE.Vector4,r=new THREE.Vector3,w=new THREE.Vector3,
t=new THREE.Vector4,u=new THREE.Matrix4,c=new THREE.PerspectiveCamera,x=new THREE.WebGLRenderTarget(f,z,{minFilter:THREE.LinearFilter,magFilter:THREE.LinearFilter,format:THREE.RGBFormat,stencilBuffer:!1});THREE.Math.isPowerOfTwo(f)&&THREE.Math.isPowerOfTwo(z)||(x.texture.generateMipmaps=!1);f=new THREE.ShaderMaterial({uniforms:THREE.UniformsUtils.clone(n.uniforms),fragmentShader:n.fragmentShader,vertexShader:n.vertexShader});f.uniforms.tDiffuse.value=x.texture;f.uniforms.color.value=B;f.uniforms.textureMatrix.value=
u;this.material=f;this.onBeforeRender=function(e,a,d){if("recursion"in d.userData){if(d.userData.recursion===D)return;d.userData.recursion++}l.setFromMatrixPosition(m.matrixWorld);y.setFromMatrixPosition(d.matrixWorld);p.extractRotation(m.matrixWorld);h.set(0,0,1);h.applyMatrix4(p);r.subVectors(l,y);if(!(0<r.dot(h))){r.reflect(h).negate();r.add(l);p.extractRotation(d.matrixWorld);v.set(0,0,-1);v.applyMatrix4(p);v.add(y);w.subVectors(l,v);w.reflect(h).negate();w.add(l);c.position.copy(r);c.up.set(0,
1,0);c.up.applyMatrix4(p);c.up.reflect(h);c.lookAt(w);c.far=d.far;c.updateMatrixWorld();c.projectionMatrix.copy(d.projectionMatrix);c.userData.recursion=0;u.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1);u.multiply(c.projectionMatrix);u.multiply(c.matrixWorldInverse);u.multiply(m.matrixWorld);k.setFromNormalAndCoplanarPoint(h,l);k.applyMatrix4(c.matrixWorldInverse);g.set(k.normal.x,k.normal.y,k.normal.z,k.constant);var b=c.projectionMatrix;t.x=(Math.sign(g.x)+b.elements[8])/b.elements[0];t.y=(Math.sign(g.y)+
b.elements[9])/b.elements[5];t.z=-1;t.w=(1+b.elements[10])/b.elements[14];g.multiplyScalar(2/g.dot(t));b.elements[2]=g.x;b.elements[6]=g.y;b.elements[10]=g.z+1-C;b.elements[14]=g.w;m.visible=!1;var b=e.getRenderTarget(),f=e.vr.enabled,n=e.shadowMap.autoUpdate;e.vr.enabled=!1;e.shadowMap.autoUpdate=!1;e.render(a,c,x,!0);e.vr.enabled=f;e.shadowMap.autoUpdate=n;e.setRenderTarget(b);a=d.bounds;void 0!==a&&(d=e.getSize(),b=e.getPixelRatio(),q.x=a.x*d.width*b,q.y=a.y*d.height*b,q.z=a.z*d.width*b,q.w=a.w*
d.height*b,e.state.viewport(q));m.visible=!0}};this.getRenderTarget=function(){return x}};THREE.Reflector.prototype=Object.create(THREE.Mesh.prototype);THREE.Reflector.prototype.constructor=THREE.Reflector;
THREE.Reflector.ReflectorShader={uniforms:{color:{type:"c",value:null},tDiffuse:{type:"t",value:null},textureMatrix:{type:"m4",value:null}},vertexShader:"uniform mat4 textureMatrix;\nvarying vec4 vUv;\nvoid main() {\n\tvUv \x3d textureMatrix * vec4( position, 1.0 );\n\tgl_Position \x3d projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",fragmentShader:"uniform vec3 color;\nuniform sampler2D tDiffuse;\nvarying vec4 vUv;\nfloat blendOverlay( float base, float blend ) {\n\treturn( base \x3c 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n}\nvec3 blendOverlay( vec3 base, vec3 blend ) {\n\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n}\nvoid main() {\n\tvec4 base \x3d texture2DProj( tDiffuse, vUv );\n\tgl_FragColor \x3d vec4( blendOverlay( base.rgb, color ), 1.0 );\n}"};