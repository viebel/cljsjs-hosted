THREE.Water=function(z,a){THREE.Mesh.call(this,z);var h=this;a=a||{};var k=void 0!==a.textureWidth?a.textureWidth:512,r=void 0!==a.textureHeight?a.textureHeight:512,A=void 0!==a.clipBias?a.clipBias:0,B=void 0!==a.alpha?a.alpha:1,C=void 0!==a.time?a.time:0,D=void 0!==a.waterNormals?a.waterNormals:null,E=void 0!==a.sunDirection?a.sunDirection:new THREE.Vector3(.70707,.70707,0),F=new THREE.Color(void 0!==a.sunColor?a.sunColor:16777215),G=new THREE.Color(void 0!==a.waterColor?a.waterColor:8355711),y=
void 0!==a.eye?a.eye:new THREE.Vector3(0,0,0),H=void 0!==a.distortionScale?a.distortionScale:20,b=void 0!==a.side?a.side:THREE.FrontSide,I=void 0!==a.fog?a.fog:!1,l=new THREE.Plane,f=new THREE.Vector3,m=new THREE.Vector3,w=new THREE.Vector3,n=new THREE.Matrix4,t=new THREE.Vector3(0,0,-1),e=new THREE.Vector4,p=new THREE.Vector3,u=new THREE.Vector3,q=new THREE.Vector4,v=new THREE.Matrix4,c=new THREE.PerspectiveCamera,x=new THREE.WebGLRenderTarget(k,r,{minFilter:THREE.LinearFilter,magFilter:THREE.LinearFilter,
format:THREE.RGBFormat,stencilBuffer:!1});THREE.Math.isPowerOfTwo(k)&&THREE.Math.isPowerOfTwo(r)||(x.texture.generateMipmaps=!1);var k=THREE.UniformsUtils.merge([THREE.UniformsLib.fog,THREE.UniformsLib.lights,{normalSampler:{value:null},mirrorSampler:{value:null},alpha:{value:1},time:{value:0},size:{value:1},distortionScale:{value:20},textureMatrix:{value:new THREE.Matrix4},sunColor:{value:new THREE.Color(8355711)},sunDirection:{value:new THREE.Vector3(.70707,.70707,0)},eye:{value:new THREE.Vector3},
waterColor:{value:new THREE.Color(5592405)}}]),r=["uniform mat4 textureMatrix;\nuniform float time;\nvarying vec4 mirrorCoord;\nvarying vec4 worldPosition;",THREE.ShaderChunk.fog_pars_vertex,THREE.ShaderChunk.shadowmap_pars_vertex,"void main() {\n\tmirrorCoord \x3d modelMatrix * vec4( position, 1.0 );\n\tworldPosition \x3d mirrorCoord.xyzw;\n\tmirrorCoord \x3d textureMatrix * mirrorCoord;\n\tvec4 mvPosition \x3d  modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position \x3d projectionMatrix * mvPosition;",
THREE.ShaderChunk.fog_vertex,THREE.ShaderChunk.shadowmap_vertex,"}"].join("\n"),J=["uniform sampler2D mirrorSampler;\nuniform float alpha;\nuniform float time;\nuniform float size;\nuniform float distortionScale;\nuniform sampler2D normalSampler;\nuniform vec3 sunColor;\nuniform vec3 sunDirection;\nuniform vec3 eye;\nuniform vec3 waterColor;\nvarying vec4 mirrorCoord;\nvarying vec4 worldPosition;\nvec4 getNoise( vec2 uv ) {\n\tvec2 uv0 \x3d ( uv / 103.0 ) + vec2(time / 17.0, time / 29.0);\n\tvec2 uv1 \x3d uv / 107.0-vec2( time / -19.0, time / 31.0 );\n\tvec2 uv2 \x3d uv / vec2( 8907.0, 9803.0 ) + vec2( time / 101.0, time / 97.0 );\n\tvec2 uv3 \x3d uv / vec2( 1091.0, 1027.0 ) - vec2( time / 109.0, time / -113.0 );\n\tvec4 noise \x3d texture2D( normalSampler, uv0 ) +\n\t\ttexture2D( normalSampler, uv1 ) +\n\t\ttexture2D( normalSampler, uv2 ) +\n\t\ttexture2D( normalSampler, uv3 );\n\treturn noise * 0.5 - 1.0;\n}\nvoid sunLight( const vec3 surfaceNormal, const vec3 eyeDirection, float shiny, float spec, float diffuse, inout vec3 diffuseColor, inout vec3 specularColor ) {\n\tvec3 reflection \x3d normalize( reflect( -sunDirection, surfaceNormal ) );\n\tfloat direction \x3d max( 0.0, dot( eyeDirection, reflection ) );\n\tspecularColor +\x3d pow( direction, shiny ) * sunColor * spec;\n\tdiffuseColor +\x3d max( dot( sunDirection, surfaceNormal ), 0.0 ) * sunColor * diffuse;\n}",
THREE.ShaderChunk.common,THREE.ShaderChunk.packing,THREE.ShaderChunk.bsdfs,THREE.ShaderChunk.fog_pars_fragment,THREE.ShaderChunk.lights_pars_begin,THREE.ShaderChunk.shadowmap_pars_fragment,THREE.ShaderChunk.shadowmask_pars_fragment,"void main() {\n\tvec4 noise \x3d getNoise( worldPosition.xz * size );\n\tvec3 surfaceNormal \x3d normalize( noise.xzy * vec3( 1.5, 1.0, 1.5 ) );\n\tvec3 diffuseLight \x3d vec3(0.0);\n\tvec3 specularLight \x3d vec3(0.0);\n\tvec3 worldToEye \x3d eye-worldPosition.xyz;\n\tvec3 eyeDirection \x3d normalize( worldToEye );\n\tsunLight( surfaceNormal, eyeDirection, 100.0, 2.0, 0.5, diffuseLight, specularLight );\n\tfloat distance \x3d length(worldToEye);\n\tvec2 distortion \x3d surfaceNormal.xz * ( 0.001 + 1.0 / distance ) * distortionScale;\n\tvec3 reflectionSample \x3d vec3( texture2D( mirrorSampler, mirrorCoord.xy / mirrorCoord.z + distortion ) );\n\tfloat theta \x3d max( dot( eyeDirection, surfaceNormal ), 0.0 );\n\tfloat rf0 \x3d 0.3;\n\tfloat reflectance \x3d rf0 + ( 1.0 - rf0 ) * pow( ( 1.0 - theta ), 5.0 );\n\tvec3 scatter \x3d max( 0.0, dot( surfaceNormal, eyeDirection ) ) * waterColor;\n\tvec3 albedo \x3d mix( ( sunColor * diffuseLight * 0.3 + scatter ) * getShadowMask(), ( vec3( 0.1 ) + reflectionSample * 0.9 + reflectionSample * specularLight ), reflectance);\n\tvec3 outgoingLight \x3d albedo;\n\tgl_FragColor \x3d vec4( outgoingLight, alpha );",
THREE.ShaderChunk.tonemapping_fragment,THREE.ShaderChunk.fog_fragment,"}"].join("\n"),b=new THREE.ShaderMaterial({fragmentShader:J,vertexShader:r,uniforms:THREE.UniformsUtils.clone(k),transparent:!0,lights:!0,side:b,fog:I});b.uniforms.mirrorSampler.value=x.texture;b.uniforms.textureMatrix.value=v;b.uniforms.alpha.value=B;b.uniforms.time.value=C;b.uniforms.normalSampler.value=D;b.uniforms.sunColor.value=F;b.uniforms.waterColor.value=G;b.uniforms.sunDirection.value=E;b.uniforms.distortionScale.value=
H;b.uniforms.eye.value=y;h.material=b;h.onBeforeRender=function(a,b,g){m.setFromMatrixPosition(h.matrixWorld);w.setFromMatrixPosition(g.matrixWorld);n.extractRotation(h.matrixWorld);f.set(0,0,1);f.applyMatrix4(n);p.subVectors(m,w);if(!(0<p.dot(f))){p.reflect(f).negate();p.add(m);n.extractRotation(g.matrixWorld);t.set(0,0,-1);t.applyMatrix4(n);t.add(w);u.subVectors(m,t);u.reflect(f).negate();u.add(m);c.position.copy(p);c.up.set(0,1,0);c.up.applyMatrix4(n);c.up.reflect(f);c.lookAt(u);c.far=g.far;c.updateMatrixWorld();
c.projectionMatrix.copy(g.projectionMatrix);v.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1);v.multiply(c.projectionMatrix);v.multiply(c.matrixWorldInverse);l.setFromNormalAndCoplanarPoint(f,m);l.applyMatrix4(c.matrixWorldInverse);e.set(l.normal.x,l.normal.y,l.normal.z,l.constant);var d=c.projectionMatrix;q.x=(Math.sign(e.x)+d.elements[8])/d.elements[0];q.y=(Math.sign(e.y)+d.elements[9])/d.elements[5];q.z=-1;q.w=(1+d.elements[10])/d.elements[14];e.multiplyScalar(2/e.dot(q));d.elements[2]=e.x;d.elements[6]=
e.y;d.elements[10]=e.z+1-A;d.elements[14]=e.w;y.setFromMatrixPosition(g.matrixWorld);g=a.getRenderTarget();var d=a.vr.enabled,k=a.shadowMap.autoUpdate;h.visible=!1;a.vr.enabled=!1;a.shadowMap.autoUpdate=!1;a.render(b,c,x,!0);h.visible=!0;a.vr.enabled=d;a.shadowMap.autoUpdate=k;a.setRenderTarget(g)}}};THREE.Water.prototype=Object.create(THREE.Mesh.prototype);THREE.Water.prototype.constructor=THREE.Water;