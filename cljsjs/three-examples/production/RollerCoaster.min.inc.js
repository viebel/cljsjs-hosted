function RollerCoasterGeometry(q,n){function e(b,c){F.set(0,0,-1).applyQuaternion(l);for(var m=0;m<b.length;m++)x.copy(b[m]),x.applyQuaternion(l),x.add(w),f.push(x.x,x.y,x.z),a.push(F.x,F.y,F.z),h.push(c[0],c[1],c[2]);F.set(0,0,1).applyQuaternion(l);for(m=b.length-1;0<=m;m--)x.copy(b[m]),x.applyQuaternion(l),x.add(w),f.push(x.x,x.y,x.z),a.push(F.x,F.y,F.z),h.push(c[0],c[1],c[2])}function k(b,c,m){for(var k=0,d=b.length;k<d;k++){var e=b[k],g=b[(k+1)%d];I.copy(e).add(c);I.applyQuaternion(l);I.add(w);
B.copy(g).add(c);B.applyQuaternion(l);B.add(w);J.copy(g).add(c);J.applyQuaternion(p);J.add(v);C.copy(e).add(c);C.applyQuaternion(p);C.add(v);f.push(I.x,I.y,I.z);f.push(B.x,B.y,B.z);f.push(C.x,C.y,C.z);f.push(B.x,B.y,B.z);f.push(J.x,J.y,J.z);f.push(C.x,C.y,C.z);K.copy(e);K.applyQuaternion(l);K.normalize();D.copy(g);D.applyQuaternion(l);D.normalize();L.copy(g);L.applyQuaternion(p);L.normalize();E.copy(e);E.applyQuaternion(p);E.normalize();a.push(K.x,K.y,K.z);a.push(D.x,D.y,D.z);a.push(E.x,E.y,E.z);
a.push(D.x,D.y,D.z);a.push(L.x,L.y,L.z);a.push(E.x,E.y,E.z);h.push(m[0],m[1],m[2]);h.push(m[0],m[1],m[2]);h.push(m[0],m[1],m[2]);h.push(m[0],m[1],m[2]);h.push(m[0],m[1],m[2]);h.push(m[0],m[1],m[2])}}THREE.BufferGeometry.call(this);var f=[],a=[],h=[],b=[1,1,1],t=[1,1,0],d=new THREE.Vector3(0,1,0),r=new THREE.Vector3,A=new THREE.Vector3,l=new THREE.Quaternion,p=new THREE.Quaternion;p.setFromAxisAngle(d,Math.PI/2);var w=new THREE.Vector3,v=new THREE.Vector3;v.copy(q.getPointAt(0));for(var G=[new THREE.Vector3(-.225,
0,0),new THREE.Vector3(0,-.05,0),new THREE.Vector3(0,-.175,0),new THREE.Vector3(0,-.05,0),new THREE.Vector3(.225,0,0),new THREE.Vector3(0,-.175,0)],u=2*Math.PI,y=5,z=[],c=0;c<y;c++){var g=c/y*u;z.push(new THREE.Vector3(.06*Math.sin(g),.06*Math.cos(g),0))}for(var y=6,H=[],c=0;c<y;c++)g=c/y*u,H.push(new THREE.Vector3(.025*Math.sin(g),.025*Math.cos(g),0));for(var x=new THREE.Vector3,F=new THREE.Vector3,I=new THREE.Vector3,B=new THREE.Vector3,J=new THREE.Vector3,C=new THREE.Vector3,K=new THREE.Vector3,
D=new THREE.Vector3,L=new THREE.Vector3,E=new THREE.Vector3,u=new THREE.Vector3,c=1;c<=n;c++)w.copy(q.getPointAt(c/n)),d.set(0,1,0),r.subVectors(w,v).normalize(),A.crossVectors(d,r).normalize(),d.crossVectors(r,A),g=Math.atan2(r.x,r.z),l.setFromAxisAngle(d,g),0===c%2&&e(G,t),k(z,u.set(0,-.125,0),t),k(H,u.set(.2,0,0),b),k(H,u.set(-.2,0,0),b),v.copy(w),p.copy(l);this.addAttribute("position",new THREE.BufferAttribute(new Float32Array(f),3));this.addAttribute("normal",new THREE.BufferAttribute(new Float32Array(a),
3));this.addAttribute("color",new THREE.BufferAttribute(new Float32Array(h),3))}RollerCoasterGeometry.prototype=Object.create(THREE.BufferGeometry.prototype);
function RollerCoasterLiftersGeometry(q,n){function e(b,c,e){for(var d=0,h=b.length;d<h;d++){var g=b[d],n=b[(d+1)%h];l.copy(g);l.applyQuaternion(a);l.add(c);p.copy(n);p.applyQuaternion(a);p.add(c);w.copy(n);w.applyQuaternion(a);w.add(e);v.copy(g);v.applyQuaternion(a);v.add(e);k.push(l.x,l.y,l.z);k.push(p.x,p.y,p.z);k.push(v.x,v.y,v.z);k.push(p.x,p.y,p.z);k.push(w.x,w.y,w.z);k.push(v.x,v.y,v.z);G.copy(g);G.applyQuaternion(a);G.normalize();u.copy(n);u.applyQuaternion(a);u.normalize();y.copy(n);y.applyQuaternion(a);
y.normalize();z.copy(g);z.applyQuaternion(a);z.normalize();f.push(G.x,G.y,G.z);f.push(u.x,u.y,u.z);f.push(z.x,z.y,z.z);f.push(u.x,u.y,u.z);f.push(y.x,y.y,y.z);f.push(z.x,z.y,z.z)}}THREE.BufferGeometry.call(this);for(var k=[],f=[],a=new THREE.Quaternion,h=new THREE.Vector3(0,1,0),b=new THREE.Vector3,t=new THREE.Vector3,d=[new THREE.Vector3(0,.05,-.05),new THREE.Vector3(0,.05,.05),new THREE.Vector3(0,-.05,0)],r=[new THREE.Vector3(-.05,0,.05),new THREE.Vector3(-.05,0,-.05),new THREE.Vector3(.05,0,0)],
A=[new THREE.Vector3(.05,0,-.05),new THREE.Vector3(.05,0,.05),new THREE.Vector3(-.05,0,0)],l=new THREE.Vector3,p=new THREE.Vector3,w=new THREE.Vector3,v=new THREE.Vector3,G=new THREE.Vector3,u=new THREE.Vector3,y=new THREE.Vector3,z=new THREE.Vector3,c=new THREE.Vector3,g=new THREE.Vector3,H=1;H<=n;H++)b.copy(q.getPointAt(H/n)),t.copy(q.getTangentAt(H/n)),a.setFromAxisAngle(h,Math.atan2(t.x,t.z)),10<b.y?(c.set(-.75,-.35,0),c.applyQuaternion(a),c.add(b),g.set(.75,-.35,0),g.applyQuaternion(a),g.add(b),
e(d,c,g),c.set(-.7,-.3,0),c.applyQuaternion(a),c.add(b),g.set(-.7,-b.y,0),g.applyQuaternion(a),g.add(b),e(r,c,g),c.set(.7,-.3,0),c.applyQuaternion(a),c.add(b),g.set(.7,-b.y,0)):(c.set(0,-.2,0),c.applyQuaternion(a),c.add(b),g.set(0,-b.y,0)),g.applyQuaternion(a),g.add(b),e(A,c,g);this.addAttribute("position",new THREE.BufferAttribute(new Float32Array(k),3));this.addAttribute("normal",new THREE.BufferAttribute(new Float32Array(f),3))}RollerCoasterLiftersGeometry.prototype=Object.create(THREE.BufferGeometry.prototype);
function RollerCoasterShadowGeometry(q,n){THREE.BufferGeometry.call(this);var e=[],k=new THREE.Vector3(0,1,0),f=new THREE.Vector3,a=new THREE.Quaternion,h=new THREE.Quaternion;h.setFromAxisAngle(k,Math.PI/2);var b=new THREE.Vector3,t=new THREE.Vector3;t.copy(q.getPointAt(0));t.y=0;for(var d=new THREE.Vector3,r=new THREE.Vector3,A=new THREE.Vector3,l=new THREE.Vector3,p=1;p<=n;p++)b.copy(q.getPointAt(p/n)),b.y=0,f.subVectors(b,t),a.setFromAxisAngle(k,Math.atan2(f.x,f.z)),d.set(-.3,0,0),d.applyQuaternion(a),
d.add(b),r.set(.3,0,0),r.applyQuaternion(a),r.add(b),A.set(.3,0,0),A.applyQuaternion(h),A.add(t),l.set(-.3,0,0),l.applyQuaternion(h),l.add(t),e.push(d.x,d.y,d.z),e.push(r.x,r.y,r.z),e.push(l.x,l.y,l.z),e.push(r.x,r.y,r.z),e.push(A.x,A.y,A.z),e.push(l.x,l.y,l.z),t.copy(b),h.copy(a);this.addAttribute("position",new THREE.BufferAttribute(new Float32Array(e),3))}RollerCoasterShadowGeometry.prototype=Object.create(THREE.BufferGeometry.prototype);
function SkyGeometry(){THREE.BufferGeometry.call(this);for(var q=[],n=0;100>n;n++){var e=800*Math.random()-400,k=50*Math.random()+50,f=800*Math.random()-400,a=40*Math.random()+20;q.push(e-a,k,f-a);q.push(e+a,k,f-a);q.push(e-a,k,f+a);q.push(e+a,k,f-a);q.push(e+a,k,f+a);q.push(e-a,k,f+a)}this.addAttribute("position",new THREE.BufferAttribute(new Float32Array(q),3))}SkyGeometry.prototype=Object.create(THREE.BufferGeometry.prototype);
function TreesGeometry(q){THREE.BufferGeometry.call(this);var n=[],e=[],k=new THREE.Raycaster;k.ray.direction.set(0,-1,0);for(var f=0;2E3>f;f++){var a=500*Math.random()-250,h=500*Math.random()-250;k.ray.origin.set(a,50,h);var b=k.intersectObject(q);if(0!==b.length){var b=b[0].point.y,t=5*Math.random()+.5,d=Math.random()*Math.PI*2;n.push(a+Math.sin(d),b,h+Math.cos(d));n.push(a,b+t,h);n.push(a+Math.sin(d+Math.PI),b,h+Math.cos(d+Math.PI));d+=Math.PI/2;n.push(a+Math.sin(d),b,h+Math.cos(d));n.push(a,b+
t,h);n.push(a+Math.sin(d+Math.PI),b,h+Math.cos(d+Math.PI));a=.1*Math.random();for(h=0;6>h;h++)e.push(.2+a,.4+a,0)}}this.addAttribute("position",new THREE.BufferAttribute(new Float32Array(n),3));this.addAttribute("color",new THREE.BufferAttribute(new Float32Array(e),3))}TreesGeometry.prototype=Object.create(THREE.BufferGeometry.prototype);