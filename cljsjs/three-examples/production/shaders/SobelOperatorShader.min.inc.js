THREE.SobelOperatorShader={uniforms:{tDiffuse:{value:null},resolution:{value:new THREE.Vector2}},vertexShader:"varying vec2 vUv;\nvoid main() {\nvUv \x3d uv;\ngl_Position \x3d projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",fragmentShader:"uniform sampler2D tDiffuse;\nuniform vec2 resolution;\nvarying vec2 vUv;\nvoid main() {\nvec2 texel \x3d vec2( 1.0 / resolution.x, 1.0 / resolution.y );\nconst mat3 Gx \x3d mat3( -1, -2, -1, 0, 0, 0, 1, 2, 1 );\nconst mat3 Gy \x3d mat3( -1, 0, 1, -2, 0, 2, -1, 0, 1 );\nfloat tx0y0 \x3d texture2D( tDiffuse, vUv + texel * vec2( -1, -1 ) ).r;\nfloat tx0y1 \x3d texture2D( tDiffuse, vUv + texel * vec2( -1,  0 ) ).r;\nfloat tx0y2 \x3d texture2D( tDiffuse, vUv + texel * vec2( -1,  1 ) ).r;\nfloat tx1y0 \x3d texture2D( tDiffuse, vUv + texel * vec2(  0, -1 ) ).r;\nfloat tx1y1 \x3d texture2D( tDiffuse, vUv + texel * vec2(  0,  0 ) ).r;\nfloat tx1y2 \x3d texture2D( tDiffuse, vUv + texel * vec2(  0,  1 ) ).r;\nfloat tx2y0 \x3d texture2D( tDiffuse, vUv + texel * vec2(  1, -1 ) ).r;\nfloat tx2y1 \x3d texture2D( tDiffuse, vUv + texel * vec2(  1,  0 ) ).r;\nfloat tx2y2 \x3d texture2D( tDiffuse, vUv + texel * vec2(  1,  1 ) ).r;\nfloat valueGx \x3d Gx[0][0] * tx0y0 + Gx[1][0] * tx1y0 + Gx[2][0] * tx2y0 + \nGx[0][1] * tx0y1 + Gx[1][1] * tx1y1 + Gx[2][1] * tx2y1 + \nGx[0][2] * tx0y2 + Gx[1][2] * tx1y2 + Gx[2][2] * tx2y2; \nfloat valueGy \x3d Gy[0][0] * tx0y0 + Gy[1][0] * tx1y0 + Gy[2][0] * tx2y0 + \nGy[0][1] * tx0y1 + Gy[1][1] * tx1y1 + Gy[2][1] * tx2y1 + \nGy[0][2] * tx0y2 + Gy[1][2] * tx1y2 + Gy[2][2] * tx2y2; \nfloat G \x3d sqrt( ( valueGx * valueGx ) + ( valueGy * valueGy ) );\ngl_FragColor \x3d vec4( vec3( G ), 1 );\n}"};