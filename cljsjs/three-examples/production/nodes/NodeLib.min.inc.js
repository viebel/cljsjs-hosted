THREE.NodeLib={nodes:{},keywords:{},add:function(a){this.nodes[a.name]=a},addKeyword:function(a,b,c){this.keywords[a]={callback:b,cache:void 0!==c?c:!0}},remove:function(a){delete this.nodes[a.name]},removeKeyword:function(a){delete this.keywords[a]},get:function(a){return this.nodes[a]},getKeyword:function(a,b){return this.keywords[a].callback.call(this,b)},getKeywordData:function(a){return this.keywords[a]},contains:function(a){return void 0!=this.nodes[a]},containsKeyword:function(a){return void 0!=
this.keywords[a]}};THREE.NodeLib.addKeyword("uv",function(){return new THREE.UVNode});THREE.NodeLib.addKeyword("uv2",function(){return new THREE.UVNode(1)});THREE.NodeLib.addKeyword("position",function(){return new THREE.PositionNode});THREE.NodeLib.addKeyword("worldPosition",function(){return new THREE.PositionNode(THREE.PositionNode.WORLD)});THREE.NodeLib.addKeyword("normal",function(){return new THREE.NormalNode});THREE.NodeLib.addKeyword("worldNormal",function(){return new THREE.NormalNode(THREE.NormalNode.WORLD)});
THREE.NodeLib.addKeyword("viewPosition",function(){return new THREE.PositionNode(THREE.NormalNode.VIEW)});THREE.NodeLib.addKeyword("viewNormal",function(){return new THREE.NormalNode(THREE.NormalNode.VIEW)});THREE.NodeLib.addKeyword("time",function(){return new THREE.TimerNode});THREE.NodeLib.add(new THREE.ConstNode("vec3 LUMA vec3(0.2125, 0.7154, 0.0721)"));
THREE.NodeLib.add(new THREE.FunctionNode("vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 map, vec2 mUv, vec2 scale ) {\n\tvec3 q0 \x3d dFdx( eye_pos );\n\tvec3 q1 \x3d dFdy( eye_pos );\n\tvec2 st0 \x3d dFdx( mUv.st );\n\tvec2 st1 \x3d dFdy( mUv.st );\n\tvec3 S \x3d normalize( q0 * st1.t - q1 * st0.t );\n\tvec3 T \x3d normalize( -q0 * st1.s + q1 * st0.s );\n\tvec3 N \x3d normalize( surf_norm );\n\tvec3 mapN \x3d map * 2.0 - 1.0;\n\tmapN.xy \x3d scale * mapN.xy;\n\tmat3 tsn \x3d mat3( S, T, N );\n\treturn normalize( tsn * mapN );\n}",null,
{derivatives:!0}));THREE.NodeLib.add(new THREE.FunctionNode("float snoise(vec2 co) {\n\treturn fract( sin( dot(co.xy, vec2(12.9898,78.233) ) ) * 43758.5453 );\n}"));THREE.NodeLib.add(new THREE.FunctionNode("vec3 hue_rgb(vec3 rgb, float adjustment) {\n\tconst mat3 RGBtoYIQ \x3d mat3(0.299, 0.587, 0.114, 0.595716, -0.274453, -0.321263, 0.211456, -0.522591, 0.311135);\n\tconst mat3 YIQtoRGB \x3d mat3(1.0, 0.9563, 0.6210, 1.0, -0.2721, -0.6474, 1.0, -1.107, 1.7046);\n\tvec3 yiq \x3d RGBtoYIQ * rgb;\n\tfloat hue \x3d atan(yiq.z, yiq.y) + adjustment;\n\tfloat chroma \x3d sqrt(yiq.z * yiq.z + yiq.y * yiq.y);\n\treturn YIQtoRGB * vec3(yiq.x, chroma * cos(hue), chroma * sin(hue));\n}"));
THREE.NodeLib.add(new THREE.FunctionNode("vec3 saturation_rgb(vec3 rgb, float adjustment) {\n\tvec3 intensity \x3d vec3(dot(rgb, LUMA));\n\treturn mix(intensity, rgb, adjustment);\n}"));THREE.NodeLib.add(new THREE.FunctionNode("float luminance_rgb(vec3 rgb) {\n\treturn dot(rgb, LUMA);\n}"));THREE.NodeLib.add(new THREE.FunctionNode("vec3 vibrance_rgb(vec3 rgb, float adjustment) {\n\tfloat average \x3d (rgb.r + rgb.g + rgb.b) / 3.0;\n\tfloat mx \x3d max(rgb.r, max(rgb.g, rgb.b));\n\tfloat amt \x3d (mx - average) * (-3.0 * adjustment);\n\treturn mix(rgb.rgb, vec3(mx), amt);\n}"));