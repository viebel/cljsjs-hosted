/**********************************************************************
 * Extern for jsts
 * Generated by http://jmmk.github.io/javascript-externs-generator
 **********************************************************************/
var jsts = {
  "algorithm": {
    "Angle": {
      "CLOCKWISE": {},
      "COUNTERCLOCKWISE": {},
      "NONE": {},
      "PI_OVER_2": {},
      "PI_OVER_4": {},
      "PI_TIMES_2": {},
      "angle": function () {},
      "angleBetween": function () {},
      "angleBetweenOriented": function () {},
      "diff": function () {},
      "getTurn": function () {},
      "interiorAngle": function () {},
      "isAcute": function () {},
      "isObtuse": function () {},
      "normalize": function () {},
      "normalizePositive": function () {},
      "toDegrees": function () {},
      "toRadians": function () {}
    },
    "CGAlgorithms": {
      "CLOCKWISE": {},
      "COLLINEAR": {},
      "COUNTERCLOCKWISE": {},
      "LEFT": {},
      "RIGHT": {},
      "STRAIGHT": {},
      "computeLength": function () {},
      "computeOrientation": function () {},
      "distanceLineLine": function () {},
      "distancePointLine": function () {},
      "distancePointLinePerpendicular": function () {},
      "isCCW": function () {},
      "isOnLine": function () {},
      "isPointInRing": function () {},
      "locatePointInRing": function () {},
      "orientationIndex": function () {},
      "signedArea": function () {}
    },
    "Centroid": {
      "area2": function () {},
      "centroid3": function () {},
      "getCentroid": function () {}
    },
    "ConvexHull": {
      "RadialComparator": {
        "polarCompare": function () {}
      },
      "extractCoordinates": function () {}
    },
    "Distance": {
      "pointToLinePerpendicular": function () {},
      "pointToSegment": function () {},
      "pointToSegmentString": function () {},
      "segmentToSegment": function () {}
    },
    "InteriorPointArea": {
      "SafeBisectorFinder": {
        "getBisectorY": function () {}
      },
      "avg": function () {},
      "centre": function () {}
    },
    "InteriorPointLine": function () {},
    "InteriorPointPoint": function () {},
    "MCPointInRing": {
      "MCSelecter": function () {}
    },
    "MinimumBoundingCircle": {
      "lowestPoint": function () {},
      "pointWitMinAngleWithX": function () {},
      "pointWithMinAngleWithSegment": function () {}
    },
    "MinimumDiameter": {
      "computeC": function () {},
      "computeSegmentForLine": function () {},
      "getMinimumDiameter": function () {},
      "getMinimumRectangle": function () {},
      "nextIndex": function () {}
    },
    "RobustLineIntersector": {
      "nearestEndpoint": function () {}
    }
  },
  "densify": {
    "Densifier": {
      "DensifyTransformer": function () {},
      "densify": function () {},
      "densifyPoints": function () {}
    }
  },
  "dissolve": {
    "LineDissolver": {
      "dissolve": function () {}
    }
  },
  "geom": {
    "Coordinate": {
      "DimensionalComparator": {
        "compare": function () {}
      },
      "NULL_ORDINATE": {},
      "X": {},
      "Y": {},
      "Z": {},
      "hashCode": function () {},
      "serialVersionUID": {}
    },
    "CoordinateList": {
      "coordArrayType": {}
    },
    "Dimension": {
      "A": {},
      "DONTCARE": {},
      "FALSE": {},
      "L": {},
      "P": {},
      "SYM_A": {},
      "SYM_DONTCARE": {},
      "SYM_FALSE": {},
      "SYM_L": {},
      "SYM_P": {},
      "SYM_TRUE": {},
      "TRUE": {},
      "toDimensionSymbol": function () {},
      "toDimensionValue": function () {}
    },
    "Envelope": {
      "intersects": function () {},
      "serialVersionUID": {}
    },
    "Geometry": {
      "TYPECODE_GEOMETRYCOLLECTION": {},
      "TYPECODE_LINEARRING": {},
      "TYPECODE_LINESTRING": {},
      "TYPECODE_MULTILINESTRING": {},
      "TYPECODE_MULTIPOINT": {},
      "TYPECODE_MULTIPOLYGON": {},
      "TYPECODE_POINT": {},
      "TYPECODE_POLYGON": {},
      "TYPENAME_GEOMETRYCOLLECTION": {},
      "TYPENAME_LINEARRING": {},
      "TYPENAME_LINESTRING": {},
      "TYPENAME_MULTILINESTRING": {},
      "TYPENAME_MULTIPOINT": {},
      "TYPENAME_MULTIPOLYGON": {},
      "TYPENAME_POINT": {},
      "TYPENAME_POLYGON": {},
      "geometryChangedFilter": {
        "filter": function () {},
        "interfaces_": function () {}
      },
      "hasNonEmptyElements": function () {},
      "hasNullElements": function () {},
      "serialVersionUID": {}
    },
    "GeometryCollection": {
      "serialVersionUID": {}
    },
    "GeometryFactory": {
      "createPointFromInternalCoord": function () {},
      "getDefaultCoordinateSequenceFactory": function () {},
      "serialVersionUID": {},
      "toGeometryArray": function () {},
      "toLineStringArray": function () {},
      "toLinearRingArray": function () {},
      "toMultiLineStringArray": function () {},
      "toMultiPointArray": function () {},
      "toMultiPolygonArray": function () {},
      "toPointArray": function () {},
      "toPolygonArray": function () {}
    },
    "IntersectionMatrix": {
      "isTrue": function () {},
      "matches": function () {}
    },
    "LineSegment": {
      "midPoint": function () {},
      "serialVersionUID": {}
    },
    "LineString": {
      "serialVersionUID": {}
    },
    "LinearRing": {
      "MINIMUM_VALID_SIZE": {},
      "serialVersionUID": {}
    },
    "Location": {
      "BOUNDARY": {},
      "EXTERIOR": {},
      "INTERIOR": {},
      "NONE": {},
      "toLocationSymbol": function () {}
    },
    "MultiLineString": {
      "serialVersionUID": {}
    },
    "MultiPoint": {
      "serialVersionUID": {}
    },
    "MultiPolygon": {
      "serialVersionUID": {}
    },
    "Point": {
      "serialVersionUID": {}
    },
    "Polygon": {
      "serialVersionUID": {}
    },
    "PrecisionModel": {
      "FIXED": {
        "_name": {},
        "getClass": function () {},
        "interfaces_": function () {},
        "readResolve": function () {},
        "toString": function () {}
      },
      "FLOATING": {
        "_name": {},
        "getClass": function () {},
        "interfaces_": function () {},
        "readResolve": function () {},
        "toString": function () {}
      },
      "FLOATING_SINGLE": {
        "_name": {},
        "getClass": function () {},
        "interfaces_": function () {},
        "readResolve": function () {},
        "toString": function () {}
      },
      "Type": {
        "nameToTypeMap": {
          "entrySet": function () {},
          "get": function () {},
          "map_": {},
          "put": function () {},
          "size": function () {},
          "values": function () {}
        },
        "serialVersionUID": {}
      },
      "maximumPreciseValue": {},
      "mostPrecise": function () {},
      "serialVersionUID": {}
    },
    "Triangle": {
      "angleBisector": function () {},
      "area": function () {},
      "area3D": function () {},
      "centroid": function () {},
      "circumcentre": function () {},
      "det": function () {},
      "inCentre": function () {},
      "interpolateZ": function () {},
      "isAcute": function () {},
      "longestSideLength": function () {},
      "perpendicularBisector": function () {},
      "signedArea": function () {}
    }
  },
  "geomgraph": {
    "GeometryGraph": {
      "determineBoundary": function () {}
    }
  },
  "index": {
    "kdtree": {
      "KdTree": {
        "BestMatchVisitor": function () {},
        "toCoordinates": function () {}
      }
    },
    "quadtree": {
      "Quadtree": {
        "ensureExtent": function () {},
        "serialVersionUID": {}
      }
    },
    "strtree": {
      "STRtree": {
        "DEFAULT_NODE_CAPACITY": {},
        "STRtreeNode": function () {},
        "avg": function () {},
        "centreX": function () {},
        "centreY": function () {},
        "getItems": function () {},
        "intersectsOp": {
          "interfaces_": function () {},
          "intersects": function () {}
        },
        "serialVersionUID": {},
        "xComparator": {
          "compare": function () {},
          "interfaces_": function () {}
        },
        "yComparator": {
          "compare": function () {},
          "interfaces_": function () {}
        }
      }
    }
  },
  "io": {
    "GeoJSONReader": function () {},
    "GeoJSONWriter": function () {},
    "OL3Parser": function () {},
    "WKTReader": function () {},
    "WKTWriter": {
      "toLineString": function () {}
    }
  },
  "linearref": {
    "LengthIndexedLine": function () {},
    "LengthLocationMap": {
      "getLength": function () {},
      "getLocation": function () {}
    },
    "LinearGeometryBuilder": function () {},
    "LinearIterator": {
      "segmentEndVertexIndex": function () {}
    },
    "LinearLocation": {
      "compareLocationValues": function () {},
      "getEndLocation": function () {},
      "pointAlongSegmentByFraction": function () {}
    },
    "LocationIndexedLine": function () {}
  },
  "noding": {
    "MCIndexNoder": {
      "SegmentOverlapAction": function () {}
    },
    "ScaledNoder": function () {},
    "SegmentString": function () {}
  },
  "operation": {
    "BoundaryOp": {
      "getBoundary": function () {}
    },
    "IsSimpleOp": {
      "EndpointInfo": function () {},
      "isSimple": function () {}
    },
    "buffer": {
      "BufferOp": {
        "CAP_BUTT": {},
        "CAP_FLAT": {},
        "CAP_ROUND": {},
        "CAP_SQUARE": {},
        "MAX_PRECISION_DIGITS": {},
        "bufferOp": function () {},
        "precisionScaleFactor": function () {}
      },
      "BufferParameters": {
        "CAP_FLAT": {},
        "CAP_ROUND": {},
        "CAP_SQUARE": {},
        "DEFAULT_MITRE_LIMIT": {},
        "DEFAULT_QUADRANT_SEGMENTS": {},
        "DEFAULT_SIMPLIFY_FACTOR": {},
        "JOIN_BEVEL": {},
        "JOIN_MITRE": {},
        "JOIN_ROUND": {},
        "bufferDistanceError": function () {}
      }
    },
    "distance": {
      "DistanceOp": {
        "distance": function () {},
        "isWithinDistance": function () {},
        "nearestPoints": function () {}
      }
    },
    "linemerge": {
      "LineMerger": function () {}
    },
    "overlay": {
      "OverlayOp": {
        "DIFFERENCE": {},
        "INTERSECTION": {},
        "SYMDIFFERENCE": {},
        "UNION": {},
        "createEmptyResult": function () {},
        "difference": function () {},
        "intersection": function () {},
        "isResultOfOp": function () {},
        "overlayOp": function () {},
        "resultDimension": function () {},
        "symDifference": function () {},
        "union": function () {}
      }
    },
    "polygonize": {
      "Polygonizer": {
        "LineStringAdder": function () {},
        "assignHoleToShell": function () {},
        "assignHolesToShells": function () {},
        "extractPolygons": function () {},
        "findDisjointShells": function () {},
        "findOuterShells": function () {}
      }
    },
    "relate": {
      "RelateOp": {
        "contains": function () {},
        "covers": function () {},
        "crosses": function () {},
        "intersects": function () {},
        "overlaps": function () {},
        "relate": function () {},
        "touches": function () {}
      }
    },
    "union": {
      "UnaryUnionOp": {
        "union": function () {}
      }
    },
    "valid": {
      "ConsistentAreaTester": function () {},
      "IsValidOp": {
        "findPtNotNode": function () {},
        "isValid": function () {}
      }
    }
  },
  "precision": {
    "GeometryPrecisionReducer": {
      "reduce": function () {},
      "reducePointwise": function () {}
    }
  },
  "simplify": {
    "DouglasPeuckerSimplifier": {
      "DPTransformer": function () {},
      "simplify": function () {}
    },
    "TopologyPreservingSimplifier": {
      "LineStringMapBuilderFilter": function () {},
      "LineStringTransformer": function () {},
      "simplify": function () {}
    }
  },
  "triangulate": {
    "ConformingDelaunayTriangulationBuilder": {
      "createConstraintSegments": function () {}
    },
    "DelaunayTriangulationBuilder": {
      "envelope": function () {},
      "extractUniqueCoordinates": function () {},
      "toVertices": function () {},
      "unique": function () {}
    },
    "VoronoiDiagramBuilder": {
      "clipGeometryCollection": function () {}
    },
    "quadedge": {
      "Vertex": {
        "BEHIND": {},
        "BETWEEN": {},
        "BEYOND": {},
        "DESTINATION": {},
        "LEFT": {},
        "ORIGIN": {},
        "RIGHT": {},
        "interpolateZ": function () {}
      }
    }
  },
  "version": {}
};
jsts.algorithm.Angle.prototype = {
  "getClass": function () {},
  "interfaces_": function () {}
};
jsts.algorithm.CGAlgorithms.prototype = {
  "getClass": function () {},
  "interfaces_": function () {}
};
jsts.algorithm.Centroid.prototype = {
  "add": function () {},
  "addHole": function () {},
  "addLineSegments": function () {},
  "addPoint": function () {},
  "addShell": function () {},
  "addTriangle": function () {},
  "getCentroid": function () {},
  "getClass": function () {},
  "interfaces_": function () {},
  "setAreaBasePoint": function () {}
};
jsts.algorithm.ConvexHull.prototype = {
  "cleanRing": function () {},
  "computeOctPts": function () {},
  "computeOctRing": function () {},
  "getClass": function () {},
  "getConvexHull": function () {},
  "grahamScan": function () {},
  "interfaces_": function () {},
  "isBetween": function () {},
  "lineOrPolygon": function () {},
  "padArray3": function () {},
  "preSort": function () {},
  "reduce": function () {},
  "toCoordinateArray": function () {}
};
jsts.algorithm.ConvexHull.RadialComparator.prototype = {
  "compare": function () {},
  "getClass": function () {},
  "interfaces_": function () {}
};
jsts.algorithm.Distance.prototype = {
  "getClass": function () {},
  "interfaces_": function () {}
};
jsts.algorithm.InteriorPointArea.prototype = {
  "add": function () {},
  "addPolygon": function () {},
  "getClass": function () {},
  "getInteriorPoint": function () {},
  "horizontalBisector": function () {},
  "interfaces_": function () {},
  "widestGeometry": function () {}
};
jsts.algorithm.InteriorPointArea.SafeBisectorFinder.prototype = {
  "getBisectorY": function () {},
  "getClass": function () {},
  "interfaces_": function () {},
  "process": function () {},
  "updateInterval": function () {}
};
jsts.algorithm.InteriorPointLine.prototype = {
  "add": function () {},
  "addEndpoints": function () {},
  "addInterior": function () {},
  "getClass": function () {},
  "getInteriorPoint": function () {},
  "interfaces_": function () {}
};
jsts.algorithm.InteriorPointPoint.prototype = {
  "add": function () {},
  "getClass": function () {},
  "getInteriorPoint": function () {},
  "interfaces_": function () {}
};
jsts.algorithm.MCPointInRing.prototype = {
  "buildIndex": function () {},
  "getClass": function () {},
  "interfaces_": function () {},
  "isInside": function () {},
  "testLineSegment": function () {},
  "testMonotoneChain": function () {}
};
jsts.algorithm.MCPointInRing.MCSelecter.prototype = {
  "constructor": function () {},
  "getClass": function () {},
  "interfaces_": function () {},
  "select": function () {}
};
jsts.algorithm.MinimumBoundingCircle.prototype = {
  "compute": function () {},
  "computeCentre": function () {},
  "computeCirclePoints": function () {},
  "getCentre": function () {},
  "getCircle": function () {},
  "getClass": function () {},
  "getDiameter": function () {},
  "getExtremalPoints": function () {},
  "getFarthestPoints": function () {},
  "getRadius": function () {},
  "interfaces_": function () {}
};
jsts.algorithm.MinimumDiameter.prototype = {
  "computeConvexRingMinDiameter": function () {},
  "computeMinimumDiameter": function () {},
  "computeWidthConvex": function () {},
  "findMaxPerpDistance": function () {},
  "getClass": function () {},
  "getDiameter": function () {},
  "getLength": function () {},
  "getMinimumRectangle": function () {},
  "getSupportingSegment": function () {},
  "getWidthCoordinate": function () {},
  "interfaces_": function () {}
};
jsts.algorithm.RobustLineIntersector.prototype = {
  "checkDD": function () {},
  "computeCollinearIntersection": function () {},
  "computeIntLineIndex": function () {},
  "computeIntersect": function () {},
  "computeIntersection": function () {},
  "constructor": function () {},
  "getClass": function () {},
  "getEdgeDistance": function () {},
  "getEndpoint": function () {},
  "getIndexAlongSegment": function () {},
  "getIntersection": function () {},
  "getIntersectionAlongSegment": function () {},
  "getIntersectionNum": function () {},
  "getTopologySummary": function () {},
  "hasIntersection": function () {},
  "interfaces_": function () {},
  "intersection": function () {},
  "intersectionWithNormalization": function () {},
  "isCollinear": function () {},
  "isEndPoint": function () {},
  "isInSegmentEnvelopes": function () {},
  "isInteriorIntersection": function () {},
  "isIntersection": function () {},
  "isProper": function () {},
  "normalizeToEnvCentre": function () {},
  "normalizeToMinimum": function () {},
  "safeHCoordinateIntersection": function () {},
  "setPrecisionModel": function () {},
  "smallestInAbsValue": function () {},
  "toString": function () {}
};
jsts.densify.Densifier.prototype = {
  "getClass": function () {},
  "getResultGeometry": function () {},
  "interfaces_": function () {},
  "setDistanceTolerance": function () {}
};
jsts.densify.Densifier.DensifyTransformer.prototype = {
  "constructor": function () {},
  "copy": function () {},
  "createCoordinateSequence": function () {},
  "createValidArea": function () {},
  "getClass": function () {},
  "getInputGeometry": function () {},
  "interfaces_": function () {},
  "transform": function () {},
  "transformCoordinates": function () {},
  "transformGeometryCollection": function () {},
  "transformLineString": function () {},
  "transformLinearRing": function () {},
  "transformMultiLineString": function () {},
  "transformMultiPoint": function () {},
  "transformMultiPolygon": function () {},
  "transformPoint": function () {},
  "transformPolygon": function () {}
};
jsts.dissolve.LineDissolver.prototype = {
  "add": function () {},
  "addLine": function () {},
  "buildLine": function () {},
  "buildLines": function () {},
  "buildRing": function () {},
  "computeResult": function () {},
  "getClass": function () {},
  "getResult": function () {},
  "interfaces_": function () {},
  "process": function () {},
  "stackEdges": function () {},
  "updateRingStartEdge": function () {}
};
jsts.geom.Coordinate.prototype = {
  "clone": function () {},
  "compareTo": function () {},
  "copy": function () {},
  "distance": function () {},
  "distance3D": function () {},
  "equalInZ": function () {},
  "equals": function () {},
  "equals2D": function () {},
  "equals3D": function () {},
  "getClass": function () {},
  "getOrdinate": function () {},
  "hashCode": function () {},
  "interfaces_": function () {},
  "setCoordinate": function () {},
  "setOrdinate": function () {},
  "toString": function () {}
};
jsts.geom.Coordinate.DimensionalComparator.prototype = {
  "compare": function () {},
  "getClass": function () {},
  "interfaces_": function () {}
};
jsts.geom.CoordinateList.prototype = {
  "add": function () {},
  "addAll": function () {},
  "clear": function () {},
  "clone": function () {},
  "closeRing": function () {},
  "constructor": function () {},
  "ensureCapacity": function () {},
  "get": function () {},
  "getClass": function () {},
  "getCoordinate": function () {},
  "interfaces_": function () {},
  "isEmpty": function () {},
  "iterator": function () {},
  "remove": function () {},
  "set": function () {},
  "size": function () {},
  "toArray": function () {},
  "toCoordinateArray": function () {}
};
jsts.geom.Dimension.prototype = {
  "getClass": function () {},
  "interfaces_": function () {}
};
jsts.geom.Envelope.prototype = {
  "centre": function () {},
  "compareTo": function () {},
  "contains": function () {},
  "covers": function () {},
  "distance": function () {},
  "equals": function () {},
  "expandBy": function () {},
  "expandToInclude": function () {},
  "getArea": function () {},
  "getClass": function () {},
  "getHeight": function () {},
  "getMaxX": function () {},
  "getMaxY": function () {},
  "getMinX": function () {},
  "getMinY": function () {},
  "getWidth": function () {},
  "hashCode": function () {},
  "init": function () {},
  "interfaces_": function () {},
  "intersection": function () {},
  "intersects": function () {},
  "isNull": function () {},
  "maxExtent": function () {},
  "minExtent": function () {},
  "setToNull": function () {},
  "toString": function () {},
  "translate": function () {}
};
jsts.geom.Geometry.prototype = {
  "buffer": function () {},
  "checkNotGeometryCollection": function () {},
  "compare": function () {},
  "compareTo": function () {},
  "contains": function () {},
  "convexHull": function () {},
  "coveredBy": function () {},
  "covers": function () {},
  "createPointFromInternalCoord": function () {},
  "crosses": function () {},
  "difference": function () {},
  "disjoint": function () {},
  "distance": function () {},
  "equal": function () {},
  "equals": function () {},
  "equalsExact": function () {},
  "equalsNorm": function () {},
  "equalsTopo": function () {},
  "geometryChanged": function () {},
  "geometryChangedAction": function () {},
  "getArea": function () {},
  "getCentroid": function () {},
  "getClass": function () {},
  "getEnvelope": function () {},
  "getEnvelopeInternal": function () {},
  "getFactory": function () {},
  "getGeometryN": function () {},
  "getInteriorPoint": function () {},
  "getLength": function () {},
  "getNumGeometries": function () {},
  "getPrecisionModel": function () {},
  "getSRID": function () {},
  "getUserData": function () {},
  "hashCode": function () {},
  "interfaces_": function () {},
  "intersection": function () {},
  "intersects": function () {},
  "isEquivalentClass": function () {},
  "isGeometryCollection": function () {},
  "isGeometryCollectionOrDerived": function () {},
  "isRectangle": function () {},
  "isSimple": function () {},
  "isValid": function () {},
  "isWithinDistance": function () {},
  "norm": function () {},
  "overlaps": function () {},
  "relate": function () {},
  "setSRID": function () {},
  "setUserData": function () {},
  "symDifference": function () {},
  "toString": function () {},
  "toText": function () {},
  "touches": function () {},
  "union": function () {},
  "within": function () {}
};
jsts.geom.GeometryCollection.prototype = {
  "apply": function () {},
  "buffer": function () {},
  "checkNotGeometryCollection": function () {},
  "compare": function () {},
  "compareTo": function () {},
  "compareToSameClass": function () {},
  "computeEnvelopeInternal": function () {},
  "constructor": function () {},
  "contains": function () {},
  "convexHull": function () {},
  "copy": function () {},
  "coveredBy": function () {},
  "covers": function () {},
  "createPointFromInternalCoord": function () {},
  "crosses": function () {},
  "difference": function () {},
  "disjoint": function () {},
  "distance": function () {},
  "equal": function () {},
  "equals": function () {},
  "equalsExact": function () {},
  "equalsNorm": function () {},
  "equalsTopo": function () {},
  "geometryChanged": function () {},
  "geometryChangedAction": function () {},
  "getArea": function () {},
  "getBoundary": function () {},
  "getBoundaryDimension": function () {},
  "getCentroid": function () {},
  "getClass": function () {},
  "getCoordinate": function () {},
  "getCoordinates": function () {},
  "getDimension": function () {},
  "getEnvelope": function () {},
  "getEnvelopeInternal": function () {},
  "getFactory": function () {},
  "getGeometryN": function () {},
  "getGeometryType": function () {},
  "getInteriorPoint": function () {},
  "getLength": function () {},
  "getNumGeometries": function () {},
  "getNumPoints": function () {},
  "getPrecisionModel": function () {},
  "getSRID": function () {},
  "getTypeCode": function () {},
  "getUserData": function () {},
  "hashCode": function () {},
  "interfaces_": function () {},
  "intersection": function () {},
  "intersects": function () {},
  "isEmpty": function () {},
  "isEquivalentClass": function () {},
  "isGeometryCollection": function () {},
  "isGeometryCollectionOrDerived": function () {},
  "isRectangle": function () {},
  "isSimple": function () {},
  "isValid": function () {},
  "isWithinDistance": function () {},
  "norm": function () {},
  "normalize": function () {},
  "overlaps": function () {},
  "relate": function () {},
  "reverse": function () {},
  "setSRID": function () {},
  "setUserData": function () {},
  "symDifference": function () {},
  "toString": function () {},
  "toText": function () {},
  "touches": function () {},
  "union": function () {},
  "within": function () {}
};
jsts.geom.GeometryFactory.prototype = {
  "buildGeometry": function () {},
  "createGeometry": function () {},
  "createGeometryCollection": function () {},
  "createLineString": function () {},
  "createLinearRing": function () {},
  "createMultiLineString": function () {},
  "createMultiPoint": function () {},
  "createMultiPointFromCoords": function () {},
  "createMultiPolygon": function () {},
  "createPoint": function () {},
  "createPolygon": function () {},
  "getClass": function () {},
  "getCoordinateSequenceFactory": function () {},
  "getPrecisionModel": function () {},
  "getSRID": function () {},
  "interfaces_": function () {},
  "toGeometry": function () {}
};
jsts.geom.IntersectionMatrix.prototype = {
  "add": function () {},
  "get": function () {},
  "getClass": function () {},
  "interfaces_": function () {},
  "isContains": function () {},
  "isCoveredBy": function () {},
  "isCovers": function () {},
  "isCrosses": function () {},
  "isDisjoint": function () {},
  "isEquals": function () {},
  "isIntersects": function () {},
  "isOverlaps": function () {},
  "isTouches": function () {},
  "isWithin": function () {},
  "matches": function () {},
  "set": function () {},
  "setAll": function () {},
  "setAtLeast": function () {},
  "setAtLeastIfValid": function () {},
  "toString": function () {},
  "transpose": function () {}
};
jsts.geom.LineSegment.prototype = {
  "angle": function () {},
  "closestPoint": function () {},
  "closestPoints": function () {},
  "compareTo": function () {},
  "distance": function () {},
  "distancePerpendicular": function () {},
  "equals": function () {},
  "equalsTopo": function () {},
  "getClass": function () {},
  "getCoordinate": function () {},
  "getLength": function () {},
  "hashCode": function () {},
  "interfaces_": function () {},
  "intersection": function () {},
  "isHorizontal": function () {},
  "isVertical": function () {},
  "lineIntersection": function () {},
  "maxX": function () {},
  "maxY": function () {},
  "midPoint": function () {},
  "minX": function () {},
  "minY": function () {},
  "normalize": function () {},
  "orientationIndex": function () {},
  "pointAlong": function () {},
  "pointAlongOffset": function () {},
  "project": function () {},
  "projectionFactor": function () {},
  "reverse": function () {},
  "segmentFraction": function () {},
  "setCoordinates": function () {},
  "toGeometry": function () {},
  "toString": function () {}
};
jsts.geom.LineString.prototype = {
  "apply": function () {},
  "buffer": function () {},
  "checkNotGeometryCollection": function () {},
  "compare": function () {},
  "compareTo": function () {},
  "compareToSameClass": function () {},
  "computeEnvelopeInternal": function () {},
  "constructor": function () {},
  "contains": function () {},
  "convexHull": function () {},
  "copy": function () {},
  "coveredBy": function () {},
  "covers": function () {},
  "createPointFromInternalCoord": function () {},
  "crosses": function () {},
  "difference": function () {},
  "disjoint": function () {},
  "distance": function () {},
  "equal": function () {},
  "equals": function () {},
  "equalsExact": function () {},
  "equalsNorm": function () {},
  "equalsTopo": function () {},
  "geometryChanged": function () {},
  "geometryChangedAction": function () {},
  "getArea": function () {},
  "getBoundary": function () {},
  "getBoundaryDimension": function () {},
  "getCentroid": function () {},
  "getClass": function () {},
  "getCoordinate": function () {},
  "getCoordinateN": function () {},
  "getCoordinateSequence": function () {},
  "getCoordinates": function () {},
  "getDimension": function () {},
  "getEndPoint": function () {},
  "getEnvelope": function () {},
  "getEnvelopeInternal": function () {},
  "getFactory": function () {},
  "getGeometryN": function () {},
  "getGeometryType": function () {},
  "getInteriorPoint": function () {},
  "getLength": function () {},
  "getNumGeometries": function () {},
  "getNumPoints": function () {},
  "getPointN": function () {},
  "getPrecisionModel": function () {},
  "getSRID": function () {},
  "getStartPoint": function () {},
  "getTypeCode": function () {},
  "getUserData": function () {},
  "hashCode": function () {},
  "init": function () {},
  "interfaces_": function () {},
  "intersection": function () {},
  "intersects": function () {},
  "isClosed": function () {},
  "isCoordinate": function () {},
  "isEmpty": function () {},
  "isEquivalentClass": function () {},
  "isGeometryCollection": function () {},
  "isGeometryCollectionOrDerived": function () {},
  "isRectangle": function () {},
  "isRing": function () {},
  "isSimple": function () {},
  "isValid": function () {},
  "isWithinDistance": function () {},
  "norm": function () {},
  "normalize": function () {},
  "overlaps": function () {},
  "relate": function () {},
  "reverse": function () {},
  "setSRID": function () {},
  "setUserData": function () {},
  "symDifference": function () {},
  "toString": function () {},
  "toText": function () {},
  "touches": function () {},
  "union": function () {},
  "within": function () {}
};
jsts.geom.LinearRing.prototype = {
  "apply": function () {},
  "buffer": function () {},
  "checkNotGeometryCollection": function () {},
  "compare": function () {},
  "compareTo": function () {},
  "compareToSameClass": function () {},
  "computeEnvelopeInternal": function () {},
  "constructor": function () {},
  "contains": function () {},
  "convexHull": function () {},
  "copy": function () {},
  "coveredBy": function () {},
  "covers": function () {},
  "createPointFromInternalCoord": function () {},
  "crosses": function () {},
  "difference": function () {},
  "disjoint": function () {},
  "distance": function () {},
  "equal": function () {},
  "equals": function () {},
  "equalsExact": function () {},
  "equalsNorm": function () {},
  "equalsTopo": function () {},
  "geometryChanged": function () {},
  "geometryChangedAction": function () {},
  "getArea": function () {},
  "getBoundary": function () {},
  "getBoundaryDimension": function () {},
  "getCentroid": function () {},
  "getClass": function () {},
  "getCoordinate": function () {},
  "getCoordinateN": function () {},
  "getCoordinateSequence": function () {},
  "getCoordinates": function () {},
  "getDimension": function () {},
  "getEndPoint": function () {},
  "getEnvelope": function () {},
  "getEnvelopeInternal": function () {},
  "getFactory": function () {},
  "getGeometryN": function () {},
  "getGeometryType": function () {},
  "getInteriorPoint": function () {},
  "getLength": function () {},
  "getNumGeometries": function () {},
  "getNumPoints": function () {},
  "getPointN": function () {},
  "getPrecisionModel": function () {},
  "getSRID": function () {},
  "getStartPoint": function () {},
  "getTypeCode": function () {},
  "getUserData": function () {},
  "hashCode": function () {},
  "init": function () {},
  "interfaces_": function () {},
  "intersection": function () {},
  "intersects": function () {},
  "isClosed": function () {},
  "isCoordinate": function () {},
  "isEmpty": function () {},
  "isEquivalentClass": function () {},
  "isGeometryCollection": function () {},
  "isGeometryCollectionOrDerived": function () {},
  "isRectangle": function () {},
  "isRing": function () {},
  "isSimple": function () {},
  "isValid": function () {},
  "isWithinDistance": function () {},
  "norm": function () {},
  "normalize": function () {},
  "overlaps": function () {},
  "relate": function () {},
  "reverse": function () {},
  "setSRID": function () {},
  "setUserData": function () {},
  "symDifference": function () {},
  "toString": function () {},
  "toText": function () {},
  "touches": function () {},
  "union": function () {},
  "validateConstruction": function () {},
  "within": function () {}
};
jsts.geom.Location.prototype = {
  "getClass": function () {},
  "interfaces_": function () {}
};
jsts.geom.MultiLineString.prototype = {
  "apply": function () {},
  "buffer": function () {},
  "checkNotGeometryCollection": function () {},
  "compare": function () {},
  "compareTo": function () {},
  "compareToSameClass": function () {},
  "computeEnvelopeInternal": function () {},
  "constructor": function () {},
  "contains": function () {},
  "convexHull": function () {},
  "copy": function () {},
  "coveredBy": function () {},
  "covers": function () {},
  "createPointFromInternalCoord": function () {},
  "crosses": function () {},
  "difference": function () {},
  "disjoint": function () {},
  "distance": function () {},
  "equal": function () {},
  "equals": function () {},
  "equalsExact": function () {},
  "equalsNorm": function () {},
  "equalsTopo": function () {},
  "geometryChanged": function () {},
  "geometryChangedAction": function () {},
  "getArea": function () {},
  "getBoundary": function () {},
  "getBoundaryDimension": function () {},
  "getCentroid": function () {},
  "getClass": function () {},
  "getCoordinate": function () {},
  "getCoordinates": function () {},
  "getDimension": function () {},
  "getEnvelope": function () {},
  "getEnvelopeInternal": function () {},
  "getFactory": function () {},
  "getGeometryN": function () {},
  "getGeometryType": function () {},
  "getInteriorPoint": function () {},
  "getLength": function () {},
  "getNumGeometries": function () {},
  "getNumPoints": function () {},
  "getPrecisionModel": function () {},
  "getSRID": function () {},
  "getTypeCode": function () {},
  "getUserData": function () {},
  "hashCode": function () {},
  "interfaces_": function () {},
  "intersection": function () {},
  "intersects": function () {},
  "isClosed": function () {},
  "isEmpty": function () {},
  "isEquivalentClass": function () {},
  "isGeometryCollection": function () {},
  "isGeometryCollectionOrDerived": function () {},
  "isRectangle": function () {},
  "isSimple": function () {},
  "isValid": function () {},
  "isWithinDistance": function () {},
  "norm": function () {},
  "normalize": function () {},
  "overlaps": function () {},
  "relate": function () {},
  "reverse": function () {},
  "setSRID": function () {},
  "setUserData": function () {},
  "symDifference": function () {},
  "toString": function () {},
  "toText": function () {},
  "touches": function () {},
  "union": function () {},
  "within": function () {}
};
jsts.geom.MultiPoint.prototype = {
  "apply": function () {},
  "buffer": function () {},
  "checkNotGeometryCollection": function () {},
  "compare": function () {},
  "compareTo": function () {},
  "compareToSameClass": function () {},
  "computeEnvelopeInternal": function () {},
  "constructor": function () {},
  "contains": function () {},
  "convexHull": function () {},
  "copy": function () {},
  "coveredBy": function () {},
  "covers": function () {},
  "createPointFromInternalCoord": function () {},
  "crosses": function () {},
  "difference": function () {},
  "disjoint": function () {},
  "distance": function () {},
  "equal": function () {},
  "equals": function () {},
  "equalsExact": function () {},
  "equalsNorm": function () {},
  "equalsTopo": function () {},
  "geometryChanged": function () {},
  "geometryChangedAction": function () {},
  "getArea": function () {},
  "getBoundary": function () {},
  "getBoundaryDimension": function () {},
  "getCentroid": function () {},
  "getClass": function () {},
  "getCoordinate": function () {},
  "getCoordinates": function () {},
  "getDimension": function () {},
  "getEnvelope": function () {},
  "getEnvelopeInternal": function () {},
  "getFactory": function () {},
  "getGeometryN": function () {},
  "getGeometryType": function () {},
  "getInteriorPoint": function () {},
  "getLength": function () {},
  "getNumGeometries": function () {},
  "getNumPoints": function () {},
  "getPrecisionModel": function () {},
  "getSRID": function () {},
  "getTypeCode": function () {},
  "getUserData": function () {},
  "hashCode": function () {},
  "interfaces_": function () {},
  "intersection": function () {},
  "intersects": function () {},
  "isEmpty": function () {},
  "isEquivalentClass": function () {},
  "isGeometryCollection": function () {},
  "isGeometryCollectionOrDerived": function () {},
  "isRectangle": function () {},
  "isSimple": function () {},
  "isValid": function () {},
  "isWithinDistance": function () {},
  "norm": function () {},
  "normalize": function () {},
  "overlaps": function () {},
  "relate": function () {},
  "reverse": function () {},
  "setSRID": function () {},
  "setUserData": function () {},
  "symDifference": function () {},
  "toString": function () {},
  "toText": function () {},
  "touches": function () {},
  "union": function () {},
  "within": function () {}
};
jsts.geom.MultiPolygon.prototype = {
  "apply": function () {},
  "buffer": function () {},
  "checkNotGeometryCollection": function () {},
  "compare": function () {},
  "compareTo": function () {},
  "compareToSameClass": function () {},
  "computeEnvelopeInternal": function () {},
  "constructor": function () {},
  "contains": function () {},
  "convexHull": function () {},
  "copy": function () {},
  "coveredBy": function () {},
  "covers": function () {},
  "createPointFromInternalCoord": function () {},
  "crosses": function () {},
  "difference": function () {},
  "disjoint": function () {},
  "distance": function () {},
  "equal": function () {},
  "equals": function () {},
  "equalsExact": function () {},
  "equalsNorm": function () {},
  "equalsTopo": function () {},
  "geometryChanged": function () {},
  "geometryChangedAction": function () {},
  "getArea": function () {},
  "getBoundary": function () {},
  "getBoundaryDimension": function () {},
  "getCentroid": function () {},
  "getClass": function () {},
  "getCoordinate": function () {},
  "getCoordinates": function () {},
  "getDimension": function () {},
  "getEnvelope": function () {},
  "getEnvelopeInternal": function () {},
  "getFactory": function () {},
  "getGeometryN": function () {},
  "getGeometryType": function () {},
  "getInteriorPoint": function () {},
  "getLength": function () {},
  "getNumGeometries": function () {},
  "getNumPoints": function () {},
  "getPrecisionModel": function () {},
  "getSRID": function () {},
  "getTypeCode": function () {},
  "getUserData": function () {},
  "hashCode": function () {},
  "interfaces_": function () {},
  "intersection": function () {},
  "intersects": function () {},
  "isEmpty": function () {},
  "isEquivalentClass": function () {},
  "isGeometryCollection": function () {},
  "isGeometryCollectionOrDerived": function () {},
  "isRectangle": function () {},
  "isSimple": function () {},
  "isValid": function () {},
  "isWithinDistance": function () {},
  "norm": function () {},
  "normalize": function () {},
  "overlaps": function () {},
  "relate": function () {},
  "reverse": function () {},
  "setSRID": function () {},
  "setUserData": function () {},
  "symDifference": function () {},
  "toString": function () {},
  "toText": function () {},
  "touches": function () {},
  "union": function () {},
  "within": function () {}
};
jsts.geom.Point.prototype = {
  "apply": function () {},
  "buffer": function () {},
  "checkNotGeometryCollection": function () {},
  "compare": function () {},
  "compareTo": function () {},
  "compareToSameClass": function () {},
  "computeEnvelopeInternal": function () {},
  "constructor": function () {},
  "contains": function () {},
  "convexHull": function () {},
  "copy": function () {},
  "coveredBy": function () {},
  "covers": function () {},
  "createPointFromInternalCoord": function () {},
  "crosses": function () {},
  "difference": function () {},
  "disjoint": function () {},
  "distance": function () {},
  "equal": function () {},
  "equals": function () {},
  "equalsExact": function () {},
  "equalsNorm": function () {},
  "equalsTopo": function () {},
  "geometryChanged": function () {},
  "geometryChangedAction": function () {},
  "getArea": function () {},
  "getBoundary": function () {},
  "getBoundaryDimension": function () {},
  "getCentroid": function () {},
  "getClass": function () {},
  "getCoordinate": function () {},
  "getCoordinateSequence": function () {},
  "getCoordinates": function () {},
  "getDimension": function () {},
  "getEnvelope": function () {},
  "getEnvelopeInternal": function () {},
  "getFactory": function () {},
  "getGeometryN": function () {},
  "getGeometryType": function () {},
  "getInteriorPoint": function () {},
  "getLength": function () {},
  "getNumGeometries": function () {},
  "getNumPoints": function () {},
  "getPrecisionModel": function () {},
  "getSRID": function () {},
  "getTypeCode": function () {},
  "getUserData": function () {},
  "getX": function () {},
  "getY": function () {},
  "hashCode": function () {},
  "init": function () {},
  "interfaces_": function () {},
  "intersection": function () {},
  "intersects": function () {},
  "isEmpty": function () {},
  "isEquivalentClass": function () {},
  "isGeometryCollection": function () {},
  "isGeometryCollectionOrDerived": function () {},
  "isRectangle": function () {},
  "isSimple": function () {},
  "isValid": function () {},
  "isWithinDistance": function () {},
  "norm": function () {},
  "normalize": function () {},
  "overlaps": function () {},
  "relate": function () {},
  "reverse": function () {},
  "setSRID": function () {},
  "setUserData": function () {},
  "symDifference": function () {},
  "toString": function () {},
  "toText": function () {},
  "touches": function () {},
  "union": function () {},
  "within": function () {}
};
jsts.geom.Polygon.prototype = {
  "apply": function () {},
  "buffer": function () {},
  "checkNotGeometryCollection": function () {},
  "compare": function () {},
  "compareTo": function () {},
  "compareToSameClass": function () {},
  "computeEnvelopeInternal": function () {},
  "constructor": function () {},
  "contains": function () {},
  "convexHull": function () {},
  "copy": function () {},
  "coveredBy": function () {},
  "covers": function () {},
  "createPointFromInternalCoord": function () {},
  "crosses": function () {},
  "difference": function () {},
  "disjoint": function () {},
  "distance": function () {},
  "equal": function () {},
  "equals": function () {},
  "equalsExact": function () {},
  "equalsNorm": function () {},
  "equalsTopo": function () {},
  "geometryChanged": function () {},
  "geometryChangedAction": function () {},
  "getArea": function () {},
  "getBoundary": function () {},
  "getBoundaryDimension": function () {},
  "getCentroid": function () {},
  "getClass": function () {},
  "getCoordinate": function () {},
  "getCoordinates": function () {},
  "getDimension": function () {},
  "getEnvelope": function () {},
  "getEnvelopeInternal": function () {},
  "getExteriorRing": function () {},
  "getFactory": function () {},
  "getGeometryN": function () {},
  "getGeometryType": function () {},
  "getInteriorPoint": function () {},
  "getInteriorRingN": function () {},
  "getLength": function () {},
  "getNumGeometries": function () {},
  "getNumInteriorRing": function () {},
  "getNumPoints": function () {},
  "getPrecisionModel": function () {},
  "getSRID": function () {},
  "getTypeCode": function () {},
  "getUserData": function () {},
  "hashCode": function () {},
  "interfaces_": function () {},
  "intersection": function () {},
  "intersects": function () {},
  "isEmpty": function () {},
  "isEquivalentClass": function () {},
  "isGeometryCollection": function () {},
  "isGeometryCollectionOrDerived": function () {},
  "isRectangle": function () {},
  "isSimple": function () {},
  "isValid": function () {},
  "isWithinDistance": function () {},
  "norm": function () {},
  "normalize": function () {},
  "overlaps": function () {},
  "relate": function () {},
  "reverse": function () {},
  "setSRID": function () {},
  "setUserData": function () {},
  "symDifference": function () {},
  "toString": function () {},
  "toText": function () {},
  "touches": function () {},
  "union": function () {},
  "within": function () {}
};
jsts.geom.PrecisionModel.prototype = {
  "compareTo": function () {},
  "equals": function () {},
  "getClass": function () {},
  "getMaximumSignificantDigits": function () {},
  "getScale": function () {},
  "getType": function () {},
  "interfaces_": function () {},
  "isFloating": function () {},
  "makePrecise": function () {},
  "setScale": function () {},
  "toString": function () {}
};
jsts.geom.PrecisionModel.Type.prototype = {
  "getClass": function () {},
  "interfaces_": function () {},
  "readResolve": function () {},
  "toString": function () {}
};
jsts.geom.Triangle.prototype = {
  "area": function () {},
  "area3D": function () {},
  "centroid": function () {},
  "circumcentre": function () {},
  "getClass": function () {},
  "inCentre": function () {},
  "interfaces_": function () {},
  "interpolateZ": function () {},
  "isAcute": function () {},
  "longestSideLength": function () {},
  "signedArea": function () {}
};
jsts.geomgraph.GeometryGraph.prototype = {
  "add": function () {},
  "addCollection": function () {},
  "addEdge": function () {},
  "addEdges": function () {},
  "addLineString": function () {},
  "addNode": function () {},
  "addPoint": function () {},
  "addPolygon": function () {},
  "addPolygonRing": function () {},
  "addSelfIntersectionNode": function () {},
  "addSelfIntersectionNodes": function () {},
  "computeEdgeIntersections": function () {},
  "computeSelfNodes": function () {},
  "computeSplitEdges": function () {},
  "constructor": function () {},
  "createEdgeSetIntersector": function () {},
  "debugPrint": function () {},
  "debugPrintln": function () {},
  "find": function () {},
  "findEdge": function () {},
  "findEdgeEnd": function () {},
  "findEdgeInSameDirection": function () {},
  "getBoundaryNodeRule": function () {},
  "getBoundaryNodes": function () {},
  "getBoundaryPoints": function () {},
  "getClass": function () {},
  "getEdgeEnds": function () {},
  "getEdgeIterator": function () {},
  "getGeometry": function () {},
  "getInvalidPoint": function () {},
  "getNodeIterator": function () {},
  "getNodes": function () {},
  "hasTooFewPoints": function () {},
  "insertBoundaryPoint": function () {},
  "insertEdge": function () {},
  "insertPoint": function () {},
  "interfaces_": function () {},
  "isBoundaryNode": function () {},
  "linkAllDirectedEdges": function () {},
  "linkResultDirectedEdges": function () {},
  "locate": function () {},
  "matchInSameDirection": function () {},
  "printEdges": function () {}
};
jsts.index.kdtree.KdTree.prototype = {
  "findBestMatchNode": function () {},
  "getClass": function () {},
  "insert": function () {},
  "insertExact": function () {},
  "interfaces_": function () {},
  "isEmpty": function () {},
  "query": function () {},
  "queryNode": function () {}
};
jsts.index.kdtree.KdTree.BestMatchVisitor.prototype = {
  "getClass": function () {},
  "getNode": function () {},
  "interfaces_": function () {},
  "queryEnvelope": function () {},
  "visit": function () {}
};
jsts.index.quadtree.Quadtree.prototype = {
  "collectStats": function () {},
  "depth": function () {},
  "getClass": function () {},
  "insert": function () {},
  "interfaces_": function () {},
  "isEmpty": function () {},
  "query": function () {},
  "queryAll": function () {},
  "remove": function () {},
  "size": function () {}
};
jsts.index.strtree.STRtree.prototype = {
  "boundablesAtLevel": function () {},
  "build": function () {},
  "constructor": function () {},
  "createHigherLevels": function () {},
  "createNode": function () {},
  "createParentBoundables": function () {},
  "createParentBoundablesFromVerticalSlice": function () {},
  "createParentBoundablesFromVerticalSlices": function () {},
  "depth": function () {},
  "getClass": function () {},
  "getComparator": function () {},
  "getIntersectsOp": function () {},
  "getNodeCapacity": function () {},
  "getRoot": function () {},
  "insert": function () {},
  "interfaces_": function () {},
  "isEmpty": function () {},
  "itemsTree": function () {},
  "lastNode": function () {},
  "nearestNeighbour": function () {},
  "query": function () {},
  "queryInternal": function () {},
  "remove": function () {},
  "removeItem": function () {},
  "size": function () {},
  "verticalSlices": function () {}
};
jsts.index.strtree.STRtree.STRtreeNode.prototype = {
  "addChildBoundable": function () {},
  "computeBounds": function () {},
  "constructor": function () {},
  "getBounds": function () {},
  "getChildBoundables": function () {},
  "getClass": function () {},
  "getLevel": function () {},
  "interfaces_": function () {},
  "isEmpty": function () {},
  "size": function () {}
};
jsts.io.GeoJSONReader.prototype = {
  "read": function () {}
};
jsts.io.GeoJSONWriter.prototype = {
  "write": function () {}
};
jsts.io.OL3Parser.prototype = {
  "convertFromCollection": function () {},
  "convertFromLineString": function () {},
  "convertFromLinearRing": function () {},
  "convertFromMultiLineString": function () {},
  "convertFromMultiPoint": function () {},
  "convertFromMultiPolygon": function () {},
  "convertFromPoint": function () {},
  "convertFromPolygon": function () {},
  "convertToCollection": function () {},
  "convertToLineString": function () {},
  "convertToLinearRing": function () {},
  "convertToMultiLineString": function () {},
  "convertToMultiPoint": function () {},
  "convertToMultiPolygon": function () {},
  "convertToPoint": function () {},
  "convertToPolygon": function () {},
  "inject": function () {},
  "read": function () {},
  "write": function () {}
};
jsts.io.WKTReader.prototype = {
  "read": function () {}
};
jsts.io.WKTWriter.prototype = {
  "write": function () {}
};
jsts.linearref.LengthIndexedLine.prototype = {
  "clampIndex": function () {},
  "extractLine": function () {},
  "extractPoint": function () {},
  "getClass": function () {},
  "getEndIndex": function () {},
  "getStartIndex": function () {},
  "indexOf": function () {},
  "indexOfAfter": function () {},
  "indicesOf": function () {},
  "interfaces_": function () {},
  "isValidIndex": function () {},
  "locationOf": function () {},
  "positiveIndex": function () {},
  "project": function () {}
};
jsts.linearref.LengthLocationMap.prototype = {
  "getClass": function () {},
  "getLength": function () {},
  "getLocation": function () {},
  "getLocationForward": function () {},
  "interfaces_": function () {},
  "resolveHigher": function () {}
};
jsts.linearref.LinearGeometryBuilder.prototype = {
  "add": function () {},
  "endLine": function () {},
  "getClass": function () {},
  "getGeometry": function () {},
  "getLastCoordinate": function () {},
  "interfaces_": function () {},
  "setFixInvalidLines": function () {},
  "setIgnoreInvalidLines": function () {},
  "validCoordinateSequence": function () {}
};
jsts.linearref.LinearIterator.prototype = {
  "getClass": function () {},
  "getComponentIndex": function () {},
  "getLine": function () {},
  "getSegmentEnd": function () {},
  "getSegmentStart": function () {},
  "getVertexIndex": function () {},
  "hasNext": function () {},
  "interfaces_": function () {},
  "isEndOfLine": function () {},
  "loadCurrentLine": function () {},
  "next": function () {}
};
jsts.linearref.LinearLocation.prototype = {
  "clamp": function () {},
  "compareLocationValues": function () {},
  "compareTo": function () {},
  "copy": function () {},
  "getClass": function () {},
  "getComponentIndex": function () {},
  "getCoordinate": function () {},
  "getSegment": function () {},
  "getSegmentFraction": function () {},
  "getSegmentIndex": function () {},
  "getSegmentLength": function () {},
  "interfaces_": function () {},
  "isEndpoint": function () {},
  "isOnSameSegment": function () {},
  "isValid": function () {},
  "isVertex": function () {},
  "normalize": function () {},
  "setToEnd": function () {},
  "snapToVertex": function () {},
  "toLowest": function () {},
  "toString": function () {}
};
jsts.linearref.LocationIndexedLine.prototype = {
  "checkGeometryType": function () {},
  "clampIndex": function () {},
  "extractLine": function () {},
  "extractPoint": function () {},
  "getClass": function () {},
  "getEndIndex": function () {},
  "getStartIndex": function () {},
  "indexOf": function () {},
  "indexOfAfter": function () {},
  "indicesOf": function () {},
  "interfaces_": function () {},
  "isValidIndex": function () {},
  "project": function () {}
};
jsts.noding.MCIndexNoder.prototype = {
  "add": function () {},
  "computeNodes": function () {},
  "constructor": function () {},
  "getClass": function () {},
  "getIndex": function () {},
  "getMonotoneChains": function () {},
  "getNodedSubstrings": function () {},
  "interfaces_": function () {},
  "intersectChains": function () {},
  "setSegmentIntersector": function () {}
};
jsts.noding.MCIndexNoder.SegmentOverlapAction.prototype = {
  "constructor": function () {},
  "getClass": function () {},
  "interfaces_": function () {},
  "overlap": function () {}
};
jsts.noding.ScaledNoder.prototype = {
  "computeNodes": function () {},
  "getClass": function () {},
  "getNodedSubstrings": function () {},
  "interfaces_": function () {},
  "isIntegerPrecision": function () {},
  "rescale": function () {},
  "scale": function () {}
};
jsts.noding.SegmentString.prototype = {
  "getClass": function () {},
  "getCoordinate": function () {},
  "getCoordinates": function () {},
  "getData": function () {},
  "interfaces_": function () {},
  "isClosed": function () {},
  "setData": function () {},
  "size": function () {}
};
jsts.operation.BoundaryOp.prototype = {
  "addEndpoint": function () {},
  "boundaryLineString": function () {},
  "boundaryMultiLineString": function () {},
  "computeBoundaryCoordinates": function () {},
  "getBoundary": function () {},
  "getClass": function () {},
  "getEmptyMultiPoint": function () {},
  "interfaces_": function () {}
};
jsts.operation.IsSimpleOp.prototype = {
  "addEndpoint": function () {},
  "computeSimple": function () {},
  "getClass": function () {},
  "getNonSimpleLocation": function () {},
  "hasClosedEndpointIntersection": function () {},
  "hasNonEndpointIntersection": function () {},
  "interfaces_": function () {},
  "isSimple": function () {},
  "isSimpleGeometryCollection": function () {},
  "isSimpleLinearGeometry": function () {},
  "isSimpleMultiPoint": function () {},
  "isSimplePolygonal": function () {}
};
jsts.operation.IsSimpleOp.EndpointInfo.prototype = {
  "addEndpoint": function () {},
  "getClass": function () {},
  "getCoordinate": function () {},
  "interfaces_": function () {}
};
jsts.operation.buffer.BufferOp.prototype = {
  "bufferFixedPrecision": function () {},
  "bufferOriginalPrecision": function () {},
  "bufferReducedPrecision": function () {},
  "computeGeometry": function () {},
  "getClass": function () {},
  "getResultGeometry": function () {},
  "interfaces_": function () {},
  "setEndCapStyle": function () {},
  "setQuadrantSegments": function () {}
};
jsts.operation.buffer.BufferParameters.prototype = {
  "getClass": function () {},
  "getEndCapStyle": function () {},
  "getJoinStyle": function () {},
  "getMitreLimit": function () {},
  "getQuadrantSegments": function () {},
  "getSimplifyFactor": function () {},
  "interfaces_": function () {},
  "isSingleSided": function () {},
  "setEndCapStyle": function () {},
  "setJoinStyle": function () {},
  "setMitreLimit": function () {},
  "setQuadrantSegments": function () {},
  "setSimplifyFactor": function () {},
  "setSingleSided": function () {}
};
jsts.operation.distance.DistanceOp.prototype = {
  "computeContainmentDistance": function () {},
  "computeFacetDistance": function () {},
  "computeMinDistance": function () {},
  "computeMinDistanceLines": function () {},
  "computeMinDistanceLinesPoints": function () {},
  "computeMinDistancePoints": function () {},
  "distance": function () {},
  "getClass": function () {},
  "interfaces_": function () {},
  "nearestLocations": function () {},
  "nearestPoints": function () {},
  "updateMinDistance": function () {}
};
jsts.operation.linemerge.LineMerger.prototype = {
  "add": function () {},
  "buildEdgeStringStartingWith": function () {},
  "buildEdgeStringsForIsolatedLoops": function () {},
  "buildEdgeStringsForNonDegree2Nodes": function () {},
  "buildEdgeStringsForObviousStartNodes": function () {},
  "buildEdgeStringsForUnprocessedNodes": function () {},
  "buildEdgeStringsStartingAt": function () {},
  "getClass": function () {},
  "getMergedLineStrings": function () {},
  "interfaces_": function () {},
  "merge": function () {}
};
jsts.operation.overlay.OverlayOp.prototype = {
  "cancelDuplicateResultEdges": function () {},
  "computeGeometry": function () {},
  "computeLabelling": function () {},
  "computeLabelsFromDepths": function () {},
  "computeOverlay": function () {},
  "constructor": function () {},
  "copyPoints": function () {},
  "findResultAreaEdges": function () {},
  "getArgGeometry": function () {},
  "getClass": function () {},
  "getGraph": function () {},
  "getResultGeometry": function () {},
  "insertUniqueEdge": function () {},
  "insertUniqueEdges": function () {},
  "interfaces_": function () {},
  "isCovered": function () {},
  "isCoveredByA": function () {},
  "isCoveredByLA": function () {},
  "labelIncompleteNode": function () {},
  "labelIncompleteNodes": function () {},
  "mergeSymLabels": function () {},
  "replaceCollapsedEdges": function () {},
  "setComputationPrecision": function () {},
  "updateNodeLabelling": function () {}
};
jsts.operation.polygonize.Polygonizer.prototype = {
  "add": function () {},
  "findShellsAndHoles": function () {},
  "findValidRings": function () {},
  "getClass": function () {},
  "getCutEdges": function () {},
  "getDangles": function () {},
  "getGeometry": function () {},
  "getInvalidRingLines": function () {},
  "getPolygons": function () {},
  "interfaces_": function () {},
  "polygonize": function () {},
  "setCheckRingsValid": function () {}
};
jsts.operation.polygonize.Polygonizer.LineStringAdder.prototype = {
  "filter": function () {},
  "getClass": function () {},
  "interfaces_": function () {}
};
jsts.operation.relate.RelateOp.prototype = {
  "constructor": function () {},
  "getArgGeometry": function () {},
  "getClass": function () {},
  "getIntersectionMatrix": function () {},
  "interfaces_": function () {},
  "setComputationPrecision": function () {}
};
jsts.operation.union.UnaryUnionOp.prototype = {
  "extract": function () {},
  "getClass": function () {},
  "interfaces_": function () {},
  "union": function () {},
  "unionNoOpt": function () {},
  "unionWithNull": function () {}
};
jsts.operation.valid.ConsistentAreaTester.prototype = {
  "getClass": function () {},
  "getInvalidPoint": function () {},
  "hasDuplicateRings": function () {},
  "interfaces_": function () {},
  "isNodeConsistentArea": function () {},
  "isNodeEdgeAreaLabelsConsistent": function () {}
};
jsts.operation.valid.IsValidOp.prototype = {
  "checkClosedRing": function () {},
  "checkClosedRings": function () {},
  "checkConnectedInteriors": function () {},
  "checkConsistentArea": function () {},
  "checkHolesInShell": function () {},
  "checkHolesNotNested": function () {},
  "checkInvalidCoordinates": function () {},
  "checkNoSelfIntersectingRing": function () {},
  "checkNoSelfIntersectingRings": function () {},
  "checkShellInsideHole": function () {},
  "checkShellNotNested": function () {},
  "checkShellsNotNested": function () {},
  "checkTooFewPoints": function () {},
  "checkValid": function () {},
  "getClass": function () {},
  "getValidationError": function () {},
  "interfaces_": function () {},
  "isValid": function () {},
  "setSelfTouchingRingFormingHoleValid": function () {}
};
jsts.precision.GeometryPrecisionReducer.prototype = {
  "changePM": function () {},
  "createEditor": function () {},
  "createFactory": function () {},
  "fixPolygonalTopology": function () {},
  "getClass": function () {},
  "interfaces_": function () {},
  "reduce": function () {},
  "reducePointwise": function () {},
  "setChangePrecisionModel": function () {},
  "setPointwise": function () {},
  "setRemoveCollapsedComponents": function () {}
};
jsts.simplify.DouglasPeuckerSimplifier.prototype = {
  "getClass": function () {},
  "getResultGeometry": function () {},
  "interfaces_": function () {},
  "setDistanceTolerance": function () {},
  "setEnsureValid": function () {}
};
jsts.simplify.DouglasPeuckerSimplifier.DPTransformer.prototype = {
  "constructor": function () {},
  "copy": function () {},
  "createCoordinateSequence": function () {},
  "createValidArea": function () {},
  "getClass": function () {},
  "getInputGeometry": function () {},
  "interfaces_": function () {},
  "transform": function () {},
  "transformCoordinates": function () {},
  "transformGeometryCollection": function () {},
  "transformLineString": function () {},
  "transformLinearRing": function () {},
  "transformMultiLineString": function () {},
  "transformMultiPoint": function () {},
  "transformMultiPolygon": function () {},
  "transformPoint": function () {},
  "transformPolygon": function () {}
};
jsts.simplify.TopologyPreservingSimplifier.prototype = {
  "getClass": function () {},
  "getResultGeometry": function () {},
  "interfaces_": function () {},
  "setDistanceTolerance": function () {}
};
jsts.simplify.TopologyPreservingSimplifier.LineStringMapBuilderFilter.prototype = {
  "filter": function () {},
  "getClass": function () {},
  "interfaces_": function () {}
};
jsts.simplify.TopologyPreservingSimplifier.LineStringTransformer.prototype = {
  "constructor": function () {},
  "copy": function () {},
  "createCoordinateSequence": function () {},
  "getClass": function () {},
  "getInputGeometry": function () {},
  "interfaces_": function () {},
  "transform": function () {},
  "transformCoordinates": function () {},
  "transformGeometryCollection": function () {},
  "transformLineString": function () {},
  "transformLinearRing": function () {},
  "transformMultiLineString": function () {},
  "transformMultiPoint": function () {},
  "transformMultiPolygon": function () {},
  "transformPoint": function () {},
  "transformPolygon": function () {}
};
jsts.triangulate.ConformingDelaunayTriangulationBuilder.prototype = {
  "create": function () {},
  "createSiteVertices": function () {},
  "createVertices": function () {},
  "getClass": function () {},
  "getEdges": function () {},
  "getSubdivision": function () {},
  "getTriangles": function () {},
  "interfaces_": function () {},
  "setConstraints": function () {},
  "setSites": function () {},
  "setTolerance": function () {}
};
jsts.triangulate.DelaunayTriangulationBuilder.prototype = {
  "create": function () {},
  "getClass": function () {},
  "getEdges": function () {},
  "getSubdivision": function () {},
  "getTriangles": function () {},
  "interfaces_": function () {},
  "setSites": function () {},
  "setTolerance": function () {}
};
jsts.triangulate.VoronoiDiagramBuilder.prototype = {
  "create": function () {},
  "getClass": function () {},
  "getDiagram": function () {},
  "getSubdivision": function () {},
  "interfaces_": function () {},
  "setClipEnvelope": function () {},
  "setSites": function () {},
  "setTolerance": function () {}
};
jsts.triangulate.quadedge.Vertex.prototype = {
  "bisector": function () {},
  "circleCenter": function () {},
  "circumRadiusRatio": function () {},
  "classify": function () {},
  "cross": function () {},
  "crossProduct": function () {},
  "distance": function () {},
  "dot": function () {},
  "equals": function () {},
  "getClass": function () {},
  "getCoordinate": function () {},
  "getX": function () {},
  "getY": function () {},
  "getZ": function () {},
  "interfaces_": function () {},
  "interpolateZValue": function () {},
  "isCCW": function () {},
  "isInCircle": function () {},
  "leftOf": function () {},
  "magn": function () {},
  "midPoint": function () {},
  "rightOf": function () {},
  "setZ": function () {},
  "sub": function () {},
  "sum": function () {},
  "times": function () {},
  "toString": function () {}
};
/**********************************************************************
 * End Generated Extern for jsts
/**********************************************************************/
